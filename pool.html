<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>台球狗运模拟器</title>
<style>
:root{--bg1:#1a2a6c;--bg2:#b21f1f;--felt:#27ae60;--wood:#8b4513;--panel-bg:rgba(0,0,0,.85);--control-bg:rgba(0,0,0,.7)}
*{box-sizing:border-box}body{font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;margin:0;padding:15px;min-height:100vh;color:#fff;background:linear-gradient(135deg,var(--bg1),var(--bg2),var(--bg1));display:flex;flex-direction:column;align-items:center;gap:12px;overflow-x:hidden}
h1{margin:0 0 6px;text-shadow:0 2px 4px rgba(0,0,0,.5);font-size:22px;text-align:center}
.container{width:100%;max-width:1200px;display:flex;flex-direction:column;gap:14px}
.content-wrapper{display:flex;gap:15px;width:100%}@media (max-width:900px){.content-wrapper{flex-direction:column}}
.table-section{flex:1;display:flex;flex-direction:column;gap:15px}
.canvas-container{position:relative;border:3px solid var(--wood);border-radius:8px;background:var(--felt);box-shadow:0 8px 16px rgba(0,0,0,.5);overflow:hidden;cursor:crosshair;touch-action:none}
canvas{display:block;width:100%;aspect-ratio:2/1;height:auto;background:var(--felt);touch-action:none}
.controls-below{background:var(--control-bg);border-radius:10px;padding:12px;display:grid;grid-template-columns:1fr 1fr;gap:15px}
@media (max-width:600px){.controls-below{grid-template-columns:1fr}}
.control-group{display:flex;flex-direction:column;gap:8px}
.control-label{font-weight:700;font-size:14px;display:flex;justify-content:space-between}
.control-value{color:#4ecdc4;min-width:50px;text-align:right}
input[type="range"]{width:100%;height:8px;border-radius:4px;background:#333;outline:none}
.side{width:320px;background:var(--panel-bg);border-radius:10px;padding:14px;box-shadow:0 4px 8px rgba(0,0,0,.3);display:flex;flex-direction:column;gap:12px;flex-shrink:0}
@media (max-width:900px){.side{width:100%}}
.grid{display:grid;grid-template-columns:1fr;gap:10px;flex:1}
.row2{display:grid;grid-template-columns:1fr 1fr;gap:10px}@media (max-width:600px){.row2{grid-template-columns:1fr}}
label{display:block;margin-bottom:6px;font-weight:800;font-size:13px}
.btns{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;margin-top:6px}
button{padding:8px 12px;font-size:13px;font-weight:700;border:none;border-radius:5px;cursor:pointer;color:#fff;transition:all .2s;box-shadow:0 3px 5px rgba(0,0,0,.2);background:linear-gradient(to bottom,#3498db,#2980b9);flex:1;min-width:80px}
button:hover{filter:brightness(1.07);transform:translateY(-1px);box-shadow:0 5px 8px rgba(0,0,0,.28)}
button:active{transform:translateY(1px)}
#resetBtn{background:linear-gradient(to bottom,#e74c3c,#c0392b)}#stopBtn{background:linear-gradient(to bottom,#95a5a6,#7f8c8d)}
.small{font-size:12px;opacity:.9;text-align:center}
.prediction-controls{display:flex;align-items:center;gap:6px;justify-content:center}
.chip{background:rgba(255,255,255,.09);padding:10px;border-radius:8px}
.info-panel{background:var(--panel-bg);padding:12px;border-radius:8px;text-align:center;font-size:13px}
.stats{display:flex;gap:10px;justify-content:space-around;flex-wrap:wrap;margin-top:8px}
.stat-item{background:rgba(0,0,0,.5);padding:7px 12px;border-radius:6px}
.progress-wrap{display:none;gap:8px;align-items:center}.progress-wrap.show{display:flex}
progress{width:100%;height:14px}
.disabled{opacity:.55;pointer-events:none}
.smart-aim-status{text-align:center;padding:8px;background:rgba(46,204,113,.2);border-radius:6px;display:none}
.smart-aim-status.show{display:block}
.collapsible-header{display:flex;justify-content:space-between;align-items:center;cursor:pointer;background:rgba(255,255,255,.1);padding:8px 10px;border-radius:6px;margin-bottom:8px}
.collapsible-header:hover{background:rgba(255,255,255,.15)}
.collapsible-content{display:none;padding:0 0 10px 0}
.collapsible-content.show{display:block}
.expand-icon{transition:transform .3s}
.expand-icon.rotated{transform:rotate(180deg)}
.section-chip{background:rgba(255,255,255,.09);padding:10px;border-radius:8px;margin-bottom:10px}
.shot-stats{display:flex;justify-content:space-between;margin-top:5px}
.main-stats{display:flex;justify-content:space-around;font-size:16px;font-weight:bold;margin:10px 0}
.main-stat-item{text-align:center}
.main-stat-value{color:#4ecdc4;display:block;font-size:20px}
.spot-marker{position:absolute;width:6px;height:6px;background:white;border-radius:50%;pointer-events:none;z-index:10}
</style>
</head>
<body>
<h1>台球狗运模拟器</h1>

<div class="container"><div class="content-wrapper">
  <div class="table-section">
    <div class="canvas-container">
      <canvas id="poolTable" width="800" height="400"></canvas>
      <div class="spot-marker" id="spotMarker" style="display:none;"></div>
    </div>
    <div class="controls-below">
      <div class="control-group">
        <div class="control-label"><span>角度微调 (±1°):</span><span id="angleFineTuneValue" class="control-value">0.000</span>°</div>
        <input type="range" id="angleFineTune" min="-1" max="1" value="0" step="0.001"/>
      </div>
      <div class="control-group">
        <label><input type="checkbox" id="showTrajectoryDuringSimulation" style="width:auto;margin-right:8px;" checked/>运行时显示轨迹</label>
      </div>
    </div>
  </div>

  <div class="side" id="sidePanel">
    <div class="main-stats">
      <div class="main-stat-item">
        入袋数<br>
        <span class="main-stat-value" id="pottedCount">0</span>
      </div>
      <div class="main-stat-item">
        杆数<br>
        <span class="main-stat-value" id="shotCount">0</span>
      </div>
      <div class="main-stat-item">
        时间<br>
        <span class="main-stat-value" id="timeCounter">0.00</span>
      </div>
      <div class="main-stat-item">
        预测<br>
        <span class="main-stat-value" id="predictedCount">0</span>
      </div>
    </div>
    
    <div class="btns">
      <button id="stopBtn">停止所有球</button>
      <button id="resetBtn">重新开始</button>
    </div>
    
    <div class="section-chip">
      <div class="collapsible-header" onclick="toggleSection('physics')">
        <span>物理调节</span>
        <span class="expand-icon" id="physics-icon">▼</span>
      </div>
      <div class="collapsible-content" id="physics-content">
        <div class="grid">
          <div class="chip">
            <label for="massControl">白球质量: <span id="massValue">1.0</span></label>
            <input type="range" id="massControl" min="-1" max="0.5" value="0" step="0.01"/>
          </div>
          <div class="chip">
            <label for="frictionControl">桌面摩擦力: <span id="frictionValue">0.30</span></label>
            <input type="range" id="frictionControl" min="0" max="1" value="0.3" step="0.01"/>
          </div>
          <div class="row2">
            <div class="chip">
              <label for="collisionLossControl">碰撞能量损失: <span id="collisionLossValue">5</span>%</label>
              <input type="range" id="collisionLossControl" min="0" max="20" value="5" step="0.1"/>
            </div>
            <div class="chip">
              <label for="boundaryLossControl">边界能量损失: <span id="boundaryLossValue">5</span>%</label>
              <input type="range" id="boundaryLossControl" min="0" max="20" value="5" step="0.1"/>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <div class="section-chip">
      <div class="collapsible-header" onclick="toggleSection('prediction')">
        <span>预测类</span>
        <span class="expand-icon" id="prediction-icon">▼</span>
      </div>
      <div class="collapsible-content" id="prediction-content">
        <div class="grid">
          <div class="chip">
            <label for="predictionTimeControl">预测时间: <span id="predictionTimeValue">15</span>s</label>
            <input type="range" id="predictionTimeControl" min="5" max="50" value="15" step="5"/>
          </div>
          <div class="chip">
            <label>预测碰撞次数: <span id="maxCollisionsValue">2</span></label>
            <div class="prediction-controls">
              <button id="decreaseCollisionsBtn" style="padding:6px 10px;font-size:12px;">-</button>
              <span id="maxCollisionsDisplay">2</span>
              <button id="increaseCollisionsBtn" style="padding:6px 10px;font-size:12px;">+</button>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <div class="section-chip">
      <div class="collapsible-header" onclick="toggleSection('table')">
        <span>桌面设置</span>
        <span class="expand-icon" id="table-icon">▼</span>
      </div>
      <div class="collapsible-content" id="table-content">
        <div class="grid">
          <div class="chip">
            <label for="speedControl">白球初始速度: <span id="speedValue">12.00</span> 单位/秒</label>
            <input type="range" id="speedControl" min="0.1" max="30" value="12" step="0.01"/>
          </div>
          <div class="chip">
            <label>袋口大小: <span id="pocketSizeValue">0.70</span></label>
            <div class="prediction-controls">
              <button id="decreasePocketSizeBtn" style="padding:6px 10px;font-size:12px;">-</button>
              <span id="pocketSizeDisplay">0.70</span>
              <button id="increasePocketSizeBtn" style="padding:6px 10px;font-size:12px;">+</button>
            </div>
          </div>
          <div class="chip">
            <label>球排列方式:</label>
            <div class="prediction-controls">
              <button id="layout4Btn" style="padding:6px 8px;font-size:12px;">四球</button>
              <button id="layout9Btn" style="padding:6px 8px;font-size:12px;">九球</button>
              <button id="layout10Btn" style="padding:6px 8px;font-size:12px;">十球</button>
              <button id="layout15Btn" style="padding:6px 8px;font-size:12px;">十五球</button>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <div class="progress-wrap" id="smartProgressWrap">
      <progress id="smartProgress" value="0" max="2001"></progress>
      <div class="small" style="min-width:96px;text-align:right;"><span id="smartProgressText">0%</span></div>
    </div>
    <div class="smart-aim-status" id="smartAimStatus">正在帮你积攒狗运</div>
    
    <div class="info-panel">
      <div class="stats">
        <div class="stat-item">说明：瞎蒙一杆就行</div>
      </div>
    </div>
  </div>
</div>
</div>

<script>
(()=>{const $=id=>document.getElementById(id),canvas=$('poolTable'),ctx=canvas.getContext('2d',{alpha:false,desynchronized:true});
const W=20,H=10,R=.25,RED_M=1,FPS=60,DT=1/FPS,STOP_V=.01,EPS=1e-9,L=R,T=R,RR=W-R,BB=H-R;
const COLORS=['#E74C3C','#3498DB','#2ECC71','#F1C40F','#9B59B6','#1ABC9C','#E67E22','#34495E','#FF6B6B','#4ECDC4','#FFD700','#FF69B4','#8A2BE2','#00CED1','#ADFF2F','#FF4500','#20B2AA','#BA55D3','#CD5C5C','#4682B4'];
const hex2rgb=h=>[parseInt(h.slice(1,3),16),parseInt(h.slice(3,5),16),parseInt(h.slice(5,7),16)];

let v0=12,mw=1,lossC=5,fric=.3,lossB=5,smartPredT=15,maxCol=2,pocketSize=.7;
let balls=[],pockets=[],running=false,showRunTraj=true,potted=0,simT=0,aimX=0,aimY=0,aimLocked=false,aiming=false,angFine=0,raf=0,needTraj=true,needBg=true;
let onlyWhiteTimer=null,cueScratchedThisShot=false,currentLayout='default',shotCount=0,predictedPots=0,spotX=2,spotY=H/2;

const bg=document.createElement('canvas'),bgc=bg.getContext('2d',{alpha:false});
const traj=document.createElement('canvas'),tctx=traj.getContext('2d',{alpha:true});
let S=40,potRaf=0,potLast=0;

const linearToLog=v=>v>=0?1+v*9:Math.pow(10,v);
const setFine=v=>{angFine=v;$('angleFineTune').value=v;$('angleFineTuneValue').textContent=v.toFixed(3);needTraj=1;requestDraw();};
const ui=()=>{$('speedValue').textContent=v0.toFixed(2);$('massValue').textContent=mw.toFixed(1);$('collisionLossValue').textContent=lossC;
$('frictionValue').textContent=fric.toFixed(2);$('boundaryLossValue').textContent=lossB;$('predictionTimeValue').textContent=smartPredT;
$('maxCollisionsValue').textContent=maxCol;$('maxCollisionsDisplay').textContent=maxCol;$('pocketSizeValue').textContent=pocketSize.toFixed(2);
$('pocketSizeDisplay').textContent=pocketSize.toFixed(2);$('pottedCount').textContent=potted;$('timeCounter').textContent=simT.toFixed(2);
$('showTrajectoryDuringSimulation').checked=showRunTraj;$('shotCount').textContent=shotCount;$('predictedCount').textContent=predictedPots;};

const toWorld=e=>{const r=canvas.getBoundingClientRect(),ox=(typeof e.offsetX==='number')?e.offsetX:(e.clientX-r.left),oy=(typeof e.offsetY==='number')?e.offsetY:(e.clientY-r.top);
let x=ox/r.width*W,y=oy/r.height*H;return{x:Math.min(RR,Math.max(L,x)),y:Math.min(BB,Math.max(T,y))};};

const shotAngle=(w,f=angFine)=>{const dx=aimX-w.x,dy=aimY-w.y;if(Math.hypot(dx,dy)<EPS)return null;return Math.atan2(dy,dx)+f*Math.PI/180;};
const requestDraw=()=>{if(raf)return;raf=requestAnimationFrame(()=>{raf=0;draw();});};

const makeBall=(x,y,color,isWhite=false)=>({x,y,vx:0,vy:0,r:R,m:isWhite?mw:RED_M,c:color,rgb:isWhite?[255,255,255]:hex2rgb(color),w:isWhite,p:0,ccr:0,potT:0,potD:0,potX0:0,potY0:0,potR0:R,potPk:null});

const makePockets=()=>{const r=pocketSize*.5;
pockets=[
  {x:L+0.17,y:T+0.17,r,k:'c',sx:-1,sy:-1,a0:0,a1:Math.PI/2},
  {x:RR-0.17,y:T+0.17,r,k:'c',sx: 1,sy:-1,a0:Math.PI/2,a1:Math.PI},
  {x:L+0.17,y:BB-0.17,r,k:'c',sx:-1,sy: 1,a0:Math.PI*1.5,a1:Math.PI*2},
  {x:RR-0.17,y:BB-0.17,r,k:'c',sx: 1,sy: 1,a0:Math.PI,a1:Math.PI*1.5},
  {x:W/2,y:T,r,k:'t',a0:0,a1:Math.PI},
  {x:W/2,y:BB,r,k:'b',a0:Math.PI,a1:Math.PI*2}
];};

const snapAllTinyVelToZero=()=>{for(const b of balls){if(b.p)continue;if(Math.hypot(b.vx,b.vy)<STOP_V){b.vx=0;b.vy=0;}}};

const cueBreakSpot=()=>({x:spotX,y:spotY});
const pocketInwardOk=(pk,x,y)=>pk.k==='c'?( (pk.sx<0?x>=pk.x:x<=pk.x) && (pk.sy<0?y>=pk.y:y<=pk.y) ):(pk.k==='t'?y>=pk.y:y<=pk.y);
const okPocketDir=(pk,vx,vy)=>{if(Math.hypot(vx,vy)<STOP_V) return false; return pk.k==='c'?(vx*pk.sx>0&&vy*pk.sy>0):(pk.k==='t'?vy<0:vy>0);};
const inPocket=(pk,x,y,rb,vx,vy)=>{if(!pocketInwardOk(pk,x,y))return false;const dx=x-pk.x,dy=y-pk.y,rr=pk.r+rb;return dx*dx+dy*dy<rr*rr && okPocketDir(pk,vx,vy);};

const canPlaceCueAt=(x,y)=>{
  const w=balls[0]; if(!w) return false;
  if(x<L+w.r||x>RR-w.r||y<T+w.r||y>BB-w.r) return false;
  for(const pk of pockets){const dx=x-pk.x,dy=y-pk.y,rr=pk.r+w.r;if(dx*dx+dy*dy < rr*rr && pocketInwardOk(pk,x,y)) return false;}
  for(let i=1;i<balls.length;i++){const b=balls[i]; if(!b||b.p) continue; const dx=x-b.x,dy=y-b.y,md=w.r+b.r; if(dx*dx+dy*dy < (md*md + 1e-8)) return false;}
  return true;
};

const respotCueBall=()=>{
  const w=balls[0]; if(!w) return;
  const {x:x0,y:y0}=cueBreakSpot(),step=Math.max(0.01,w.r*0.2); let x=x0,y=y0;
  if(!canPlaceCueAt(x,y)){let found=false;for(let xi=x0;xi<=RR-w.r;xi+=step){if(canPlaceCueAt(xi,y0)){x=xi;found=true;break;}} if(!found) x=RR-w.r;}
  w.x=x;w.y=y;w.vx=0;w.vy=0;w.p=0;w.r=R;w.potPk=null;
  if(Math.hypot(aimX-w.x,aimY-w.y)<EPS){aimX=w.x+5;aimY=w.y;}
};

const updatePotAnims=(dt)=>{
  let any=false;
  for(const b of balls){
    if(b.p!==2) continue;
    b.potT=Math.min(b.potD,b.potT+dt);
    let t=b.potD?b.potT/b.potD:1; t=t*t*(3-2*t);
    const pk=b.potPk; if(pk){b.x=b.potX0+(pk.x-b.potX0)*t; b.y=b.potY0+(pk.y-b.potY0)*t;}
    // 球不缩小，只改变位置
    if(b.potT>=b.potD){b.p=1;b.r=R;b.potPk=null;}
    else any=true;
  }
  return any;
};
const startPotLoop=()=>{
  if(potRaf) return;
  potLast=performance.now();
  const loop=now=>{
    potRaf=0;
    const dt=Math.min(.05,(now-potLast)/1000||0); potLast=now;
    if(updatePotAnims(dt)){needTraj=1;requestDraw(); potRaf=requestAnimationFrame(loop);}
    else {needTraj=1;requestDraw();}
  };
  potRaf=requestAnimationFrame(loop);
};

const finishShotCommon=()=>{
  running=false; disableRunTraj(); aimLocked=false; setFine(0); onlyWhiteTimer=null;
  snapAllTinyVelToZero(); balls.forEach(b=>b.ccr=0);
  if(cueScratchedThisShot || (balls[0] && balls[0].p && balls[0].w)){respotCueBall();cueScratchedThisShot=false;}
  if(balls.some(b=>b.p===2)) startPotLoop();
  needTraj=1; requestDraw();
};

// 新增函数：检查两个球是否重叠
const ballsOverlap = (b1, b2) => {
  const dx = b1.x - b2.x;
  const dy = b1.y - b2.y;
  const distance = Math.sqrt(dx * dx + dy * dy);
  return distance < (b1.r + b2.r);
};

// 新增函数：调整球的位置使其不重叠
const separateBalls = (b1, b2) => {
  const dx = b1.x - b2.x;
  const dy = b1.y - b2.y;
  const distance = Math.sqrt(dx * dx + dy * dy);
  if (distance === 0) return; // 避免除零
  
  const minDistance = b1.r + b2.r;
  const overlap = minDistance - distance;
  const moveX = (overlap * dx / distance) / 2;
  const moveY = (overlap * dy / distance) / 2;
  
  b1.x += moveX;
  b1.y += moveY;
  b2.x -= moveX;
  b2.y -= moveY;
};

// 新增函数：确保所有球都不重叠
const resolveOverlaps = () => {
  let hasOverlap = true;
  const maxIterations = 100;
  let iterations = 0;
  
  while (hasOverlap && iterations < maxIterations) {
    hasOverlap = false;
    for (let i = 0; i < balls.length; i++) {
      for (let j = i + 1; j < balls.length; j++) {
        if (ballsOverlap(balls[i], balls[j])) {
          separateBalls(balls[i], balls[j]);
          hasOverlap = true;
        }
      }
    }
    iterations++;
  }
};

const createBallsLayout = (layout) => {
  balls = [];
  
  // 白球位置也加入轻微随机性
  const whiteX = spotX + (Math.random()-0.5)*0.1;
  const whiteY = spotY + (Math.random()-0.5)*0.1;
  balls.push(makeBall(whiteX, whiteY, '#fff', true)); // 白球
  
  let k = 0;
  const startX = 15;
  const startY = H/2;
  const horizontalSpacing = R * 2.2;
  const verticalSpacing = R * 2.0;
  
  if (layout === '4') {
    // 四球布局 (1-2-1)
    balls.push(makeBall(startX + (Math.random()-0.5)*0.1, startY + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    balls.push(makeBall(startX + horizontalSpacing + (Math.random()-0.5)*0.1, startY - verticalSpacing/2 + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    balls.push(makeBall(startX + horizontalSpacing + (Math.random()-0.5)*0.1, startY + verticalSpacing/2 + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    balls.push(makeBall(startX + 2 * horizontalSpacing + (Math.random()-0.5)*0.1, startY + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
  } else if (layout === '9') {
    // 九球布局 (1-2-3-2-1)
    balls.push(makeBall(startX + (Math.random()-0.5)*0.1, startY + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    
    balls.push(makeBall(startX + horizontalSpacing + (Math.random()-0.5)*0.1, startY - verticalSpacing/2 + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    balls.push(makeBall(startX + horizontalSpacing + (Math.random()-0.5)*0.1, startY + verticalSpacing/2 + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    
    balls.push(makeBall(startX + 2 * horizontalSpacing + (Math.random()-0.5)*0.1, startY - verticalSpacing + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    balls.push(makeBall(startX + 2 * horizontalSpacing + (Math.random()-0.5)*0.1, startY + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    balls.push(makeBall(startX + 2 * horizontalSpacing + (Math.random()-0.5)*0.1, startY + verticalSpacing + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    
    balls.push(makeBall(startX + 3 * horizontalSpacing + (Math.random()-0.5)*0.1, startY - verticalSpacing/2 + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    balls.push(makeBall(startX + 3 * horizontalSpacing + (Math.random()-0.5)*0.1, startY + verticalSpacing/2 + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    
    balls.push(makeBall(startX + 4 * horizontalSpacing + (Math.random()-0.5)*0.1, startY + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
  } else if (layout === '10') {
    // 十球布局 (1-2-3-4)
    balls.push(makeBall(startX + (Math.random()-0.5)*0.1, startY + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    
    balls.push(makeBall(startX + horizontalSpacing + (Math.random()-0.5)*0.1, startY - verticalSpacing/2 + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    balls.push(makeBall(startX + horizontalSpacing + (Math.random()-0.5)*0.1, startY + verticalSpacing/2 + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    
    balls.push(makeBall(startX + 2 * horizontalSpacing + (Math.random()-0.5)*0.1, startY - verticalSpacing + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    balls.push(makeBall(startX + 2 * horizontalSpacing + (Math.random()-0.5)*0.1, startY + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    balls.push(makeBall(startX + 2 * horizontalSpacing + (Math.random()-0.5)*0.1, startY + verticalSpacing + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    
    balls.push(makeBall(startX + 3 * horizontalSpacing + (Math.random()-0.5)*0.1, startY - 1.5 * verticalSpacing + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    balls.push(makeBall(startX + 3 * horizontalSpacing + (Math.random()-0.5)*0.1, startY - 0.5 * verticalSpacing + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    balls.push(makeBall(startX + 3 * horizontalSpacing + (Math.random()-0.5)*0.1, startY + 0.5 * verticalSpacing + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    balls.push(makeBall(startX + 3 * horizontalSpacing + (Math.random()-0.5)*0.1, startY + 1.5 * verticalSpacing + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
  } else if (layout === '15') {
    // 十五球布局 (1-2-3-4-5)
    balls.push(makeBall(startX + (Math.random()-0.5)*0.1, startY + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    
    balls.push(makeBall(startX + horizontalSpacing + (Math.random()-0.5)*0.1, startY - verticalSpacing/2 + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    balls.push(makeBall(startX + horizontalSpacing + (Math.random()-0.5)*0.1, startY + verticalSpacing/2 + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    
    balls.push(makeBall(startX + 2 * horizontalSpacing + (Math.random()-0.5)*0.1, startY - verticalSpacing + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    balls.push(makeBall(startX + 2 * horizontalSpacing + (Math.random()-0.5)*0.1, startY + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    balls.push(makeBall(startX + 2 * horizontalSpacing + (Math.random()-0.5)*0.1, startY + verticalSpacing + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    
    balls.push(makeBall(startX + 3 * horizontalSpacing + (Math.random()-0.5)*0.1, startY - 1.5 * verticalSpacing + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    balls.push(makeBall(startX + 3 * horizontalSpacing + (Math.random()-0.5)*0.1, startY - 0.5 * verticalSpacing + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    balls.push(makeBall(startX + 3 * horizontalSpacing + (Math.random()-0.5)*0.1, startY + 0.5 * verticalSpacing + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    balls.push(makeBall(startX + 3 * horizontalSpacing + (Math.random()-0.5)*0.1, startY + 1.5 * verticalSpacing + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    
    balls.push(makeBall(startX + 4 * horizontalSpacing + (Math.random()-0.5)*0.1, startY - 2 * verticalSpacing + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    balls.push(makeBall(startX + 4 * horizontalSpacing + (Math.random()-0.5)*0.1, startY - verticalSpacing + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    balls.push(makeBall(startX + 4 * horizontalSpacing + (Math.random()-0.5)*0.1, startY + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    balls.push(makeBall(startX + 4 * horizontalSpacing + (Math.random()-0.5)*0.1, startY + verticalSpacing + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    balls.push(makeBall(startX + 4 * horizontalSpacing + (Math.random()-0.5)*0.1, startY + 2 * verticalSpacing + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
  } else {
    // 默认布局 (1-2-3-4)
    balls.push(makeBall(startX + (Math.random()-0.5)*0.1, startY + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    
    balls.push(makeBall(startX + horizontalSpacing + (Math.random()-0.5)*0.1, startY - verticalSpacing/2 + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    balls.push(makeBall(startX + horizontalSpacing + (Math.random()-0.5)*0.1, startY + verticalSpacing/2 + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    
    balls.push(makeBall(startX + 2 * horizontalSpacing + (Math.random()-0.5)*0.1, startY - verticalSpacing + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    balls.push(makeBall(startX + 2 * horizontalSpacing + (Math.random()-0.5)*0.1, startY + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    balls.push(makeBall(startX + 2 * horizontalSpacing + (Math.random()-0.5)*0.1, startY + verticalSpacing + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    
    balls.push(makeBall(startX + 3 * horizontalSpacing + (Math.random()-0.5)*0.1, startY - 1.5 * verticalSpacing + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    balls.push(makeBall(startX + 3 * horizontalSpacing + (Math.random()-0.5)*0.1, startY - 0.5 * verticalSpacing + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    balls.push(makeBall(startX + 3 * horizontalSpacing + (Math.random()-0.5)*0.1, startY + 0.5 * verticalSpacing + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
    balls.push(makeBall(startX + 3 * horizontalSpacing + (Math.random()-0.5)*0.1, startY + 1.5 * verticalSpacing + (Math.random()-0.5)*0.1, COLORS[k++ % COLORS.length]));
  }
  
  // 调整球的位置以避免重叠
  resolveOverlaps();
};

const init=()=>{running=false;potted=0;simT=0;aimLocked=false;aiming=false;cueScratchedThisShot=false;setFine(0);makePockets();
createBallsLayout(currentLayout);
balls.forEach(b=>b.ccr=0);aimX=balls[0].x+5;aimY=balls[0].y;needBg=needTraj=1;ui();requestDraw();};

const stepBall=b=>{if(b.p) return 0;
const s=Math.hypot(b.vx,b.vy);
if(s>EPS){const ns=Math.max(0,s-fric*DT),k=ns/s; b.vx*=k;b.vy*=k; if(Math.hypot(b.vx,b.vy)<STOP_V){b.vx=0;b.vy=0;}}
b.x+=b.vx*DT; b.y+=b.vy*DT;
const blf=(100-lossB)/100; let hit=0;
if(b.x-b.r<L){b.x=L+b.r;b.vx=-b.vx*blf;hit=1;} else if(b.x+b.r>RR){b.x=RR-b.r;b.vx=-b.vx*blf;hit=1;}
if(b.y-b.r<T){b.y=T+b.r;b.vy=-b.vy*blf;hit=1;} else if(b.y+b.r>BB){b.y=BB-b.r;b.vy=-b.vy*blf;hit=1;}
return hit;};

const collide=(a,b)=>{if(a.p||b.p) return 0;
const dx=b.x-a.x,dy=b.y-a.y,md=a.r+b.r,d2=dx*dx+dy*dy;
if(d2>=md*md||d2<EPS) return 0;
const d=Math.sqrt(d2),nx=dx/d,ny=dy/d,tx=-ny,ty=nx;
const v1n=a.vx*nx+a.vy*ny,v1t=a.vx*tx+a.vy*ty,v2n=b.vx*nx+b.vy*ny,v2t=b.vx*tx+b.vy*ty,m1=a.m,m2=b.m;
const v1n2=(v1n*(m1-m2)+2*m2*v2n)/(m1+m2),v2n2=(v2n*(m2-m1)+2*m1*v1n)/(m1+m2),elf=(100-lossC)/100;
a.vx=(v1n2*nx+v1t*tx)*elf; a.vy=(v1n2*ny+v1t*ty)*elf;
b.vx=(v2n2*nx+v2t*tx)*elf; b.vy=(v2n2*ny+v2t*ty)*elf;
const ov=(md-d)/2; a.x-=ov*nx;a.y-=ov*ny; b.x+=ov*nx;b.y+=ov*ny; return 1;};

const potBall=(b,pk,countUI)=>{
  if(b.p) return;
  b.p=2; b.vx=0; b.vy=0; b.potT=0; b.potD=.4; b.potX0=b.x; b.potY0=b.y; b.potR0=R; b.potPk=pk;
  if(countUI){potted++; $('pottedCount').textContent=potted;}
};

const checkPots=countUI=>{
  for(const b of balls){
    if(b.p||b.w) continue;
    for(const pk of pockets){ if(inPocket(pk,b.x,b.y,b.r,b.vx,b.vy)){ potBall(b,pk,countUI); break; } }
  }
};

const checkCueScratch=countUI=>{
  const w=balls[0]; if(!w||w.p) return false;
  for(const pk of pockets){
    if(inPocket(pk,w.x,w.y,w.r,w.vx,w.vy)){
      cueScratchedThisShot=true; w.p=2; w.vx=0; w.vy=0; w.potT=0; w.potD=.3; w.potX0=w.x; w.potY0=w.y; w.potR0=R; w.potPk=pk;
      return true;
    }
  }
  return false;
};

function simPred({includeAim,recordSet=null,sample=1,maxSteps=60000}){
  const n=balls.length;
  const x=new Float64Array(n),y=new Float64Array(n),vx=new Float64Array(n),vy=new Float64Array(n);
  const r=new Float64Array(n),m=new Float64Array(n),p=new Uint8Array(n),w=new Uint8Array(n),cc=new Uint16Array(n),start=new Uint16Array(n);
  let wi=-1;
  for(let i=0;i<n;i++){
    const b=balls[i];
    x[i]=b.x;y[i]=b.y;vx[i]=b.vx;vy[i]=b.vy;r[i]=R;m[i]=b.m;p[i]=b.p?1:0;w[i]=b.w?1:0;cc[i]=start[i]=b.ccr||0;
    if(b.w)wi=i;
  }
  if(includeAim&&wi>=0&&!p[wi]&&Math.hypot(vx[wi],vy[wi])<STOP_V){
    const dx=aimX-x[wi],dy=aimY-y[wi],d=Math.hypot(dx,dy);
    if(d>EPS){const ang=Math.atan2(dy,dx)+angFine*Math.PI/180; vx[wi]=v0*Math.cos(ang);vy[wi]=v0*Math.sin(ang);}
  }
  const want=i=>!recordSet||recordSet.has(i);
  const trajArr=Array.from({length:n},(_,i)=>({pts:[],rgb:balls[i].rgb}));
  const blf=(100-lossB)/100,elf=(100-lossC)/100;

  let potCount = 0;
  for(let step=0;step<maxSteps;step++){
    let any=0; for(let i=0;i<n;i++) if(!p[i]&&Math.hypot(vx[i],vy[i])>=STOP_V){any=1;break;} if(!any) break;
    if(step%sample===0) for(let i=0;i<n;i++) if(want(i)&&!p[i]&&cc[i]<=start[i]+maxCol) trajArr[i].pts.push(x[i],y[i]);

    for(let i=0;i<n;i++){
      if(p[i]) continue;
      const s=Math.hypot(vx[i],vy[i]);
      if(s>EPS){const ns=Math.max(0,s-fric*DT),k=ns/s;vx[i]*=k;vy[i]*=k; if(Math.hypot(vx[i],vy[i])<STOP_V){vx[i]=0;vy[i]=0;}}
      x[i]+=vx[i]*DT; y[i]+=vy[i]*DT;
      let hit=0;
      if(x[i]-r[i]<L){x[i]=L+r[i];vx[i]=-vx[i]*blf;hit=1;} else if(x[i]+r[i]>RR){x[i]=RR-r[i];vx[i]=-vx[i]*blf;hit=1;}
      if(y[i]-r[i]<T){y[i]=T+r[i];vy[i]=-vy[i]*blf;hit=1;} else if(y[i]+r[i]>BB){y[i]=BB-r[i];vy[i]=-vy[i]*blf;hit=1;}
      if(hit) cc[i]++;
    }

    for(let i=0;i<n;i++)for(let j=i+1;j<n;j++){
      if(p[i]||p[j]) continue;
      const dx=x[j]-x[i],dy=y[j]-y[i],md=r[i]+r[j],d2=dx*dx+dy*dy;
      if(d2>=md*md||d2<EPS) continue;
      const d=Math.sqrt(d2),nx=dx/d,ny=dy/d,tx=-ny,ty=nx;
      const v1n=vx[i]*nx+vy[i]*ny,v1t=vx[i]*tx+vy[i]*ty,v2n=vx[j]*nx+vy[j]*ny,v2t=vy[j]*ty+vx[j]*tx;
      const m1=m[i],m2=m[j];
      const v1n2=(v1n*(m1-m2)+2*m2*v2n)/(m1+m2),v2n2=(v2n*(m2-m1)+2*m1*v1n)/(m1+m2);
      vx[i]=(v1n2*nx+v1t*tx)*elf;vy[i]=(v1n2*ny+v1t*ty)*elf;
      vx[j]=(v2n2*nx+v2t*tx)*elf;vy[j]=(v2n2*ny+v2t*ty)*elf;
      const ov=(md-d)/2;x[i]-=ov*nx;y[i]-=ov*ny;x[j]+=ov*nx;y[j]+=ov*ny;
      cc[i]++;cc[j]++;
    }

    for(let i=0;i<n;i++){
      if(p[i]||w[i]) continue;
      for(const pk of pockets){ 
        if(inPocket(pk,x[i],y[i],r[i],vx[i],vy[i])){
          p[i]=1;
          if(!recordSet || recordSet.has(i)) potCount++;
          break;
        }
      }
    }
    if(wi>=0&&!p[wi]) for(const pk of pockets){ if(inPocket(pk,x[wi],y[wi],r[wi],vx[wi],vy[wi])){p[wi]=1;break;} }
  }
  
  if(includeAim && !recordSet) {
    predictedPots = potCount;
    ui();
  }
  
  return trajArr;
}

const resize=()=>{const dpr=Math.min(2,window.devicePixelRatio||1),w=canvas.clientWidth||800,h=w*(H/W);
canvas.style.height=h+'px';const pxW=Math.round(w*dpr),pxH=Math.round(h*dpr);
if(canvas.width===pxW&&canvas.height===pxH)return;
canvas.width=pxW;canvas.height=pxH;bg.width=pxW;bg.height=pxH;traj.width=pxW;traj.height=pxH;
ctx.setTransform(dpr,0,0,dpr,0,0);bgc.setTransform(dpr,0,0,dpr,0,0);tctx.setTransform(dpr,0,0,dpr,0,0);
S=w/W;needBg=needTraj=1;requestDraw();};

const drawPocket=pk=>{
  const x=pk.x*S,y=pk.y*S,r=pk.r*S;
  // 绘制完整圆形袋口，不被库边覆盖
  bgc.beginPath(); 
  bgc.arc(x,y,r,0,Math.PI*2); 
  bgc.fillStyle='#000'; 
  bgc.fill();
  
  // 绘制袋口内圈
  bgc.beginPath(); 
  bgc.arc(x,y,r*.7,0,Math.PI*2); 
  bgc.fillStyle='#333'; 
  bgc.fill();
};

const drawBg=()=>{
  const w=canvas.clientWidth,h=canvas.clientHeight;
  bgc.clearRect(0,0,w,h);
  bgc.fillStyle='#27ae60'; bgc.fillRect(0,0,w,h);
  bgc.strokeStyle='#8b4513'; bgc.lineWidth=6; bgc.strokeRect(0,0,w,h);
  bgc.strokeStyle='rgba(0,0,0,.85)'; bgc.lineWidth=2;
  bgc.strokeRect(L*S,T*S,(W-2*R)*S,(H-2*R)*S);
  for(const pk of pockets) drawPocket(pk);
  needBg=0;
};

const strokePoly=(pts,rgb,dynamic)=>{if(!pts||pts.length<4)return;
const chunks=dynamic?10:1,n=pts.length/2;
for(let c=0;c<chunks;c++){
  const a0=c/chunks,a1=(c+1)/chunks,i0=Math.floor(a0*(n-1)),i1=Math.max(i0+1,Math.floor(a1*(n-1)));
  const alpha=dynamic?Math.max(.12,1-a0*.9):.65;
  tctx.strokeStyle=`rgba(${rgb[0]},${rgb[1]},${rgb[2]},${alpha})`;tctx.lineWidth=2;
  tctx.beginPath();tctx.moveTo(pts[i0*2]*S,pts[i0*2+1]*S);
  for(let i=i0+1;i<=i1;i++)tctx.lineTo(pts[i*2]*S,pts[i*2+1]*S);
  tctx.stroke();
}};

const drawTrajLayer=()=>{
  const w=canvas.clientWidth,h=canvas.clientHeight; tctx.clearRect(0,0,w,h);
  if(running){
    if(showRunTraj&&runTrajEnabled) for(let i=0;i<runTraj.length;i++){const t=runTraj[i]; if(t&&balls[i]&&!balls[i].p) strokePoly(t.pts,t.rgb,false);}
  }else{
    const t=simPred({includeAim:true,sample:1});
    for(let i=0;i<t.length;i++) if(!balls[i].p) strokePoly(t[i].pts,t[i].rgb,true);
  }
  needTraj=0;
};

const drawBalls=()=>{
  for(const b of balls){
    if(b.p===1) continue;
    ctx.beginPath(); ctx.arc(b.x*S,b.y*S,b.r*S,0,Math.PI*2);
    ctx.fillStyle=b.w?'#fff':b.c; ctx.fill();
    ctx.strokeStyle='#000'; ctx.lineWidth=1; ctx.stroke();
    if(!b.w && b.p!==2){
      ctx.beginPath(); ctx.arc(b.x*S-b.r*S*.3,b.y*S-b.r*S*.3,b.r*S*.2,0,Math.PI*2);
      ctx.fillStyle='rgba(255,255,255,.9)'; ctx.fill();
    }
  }
};

const drawAim=()=>{
  if(running) return;
  const w=balls[0]; if(!w||w.p) return;
  const ang=shotAngle(w); if(ang==null) return;
  const ux=Math.cos(ang),uy=Math.sin(ang);
  ctx.beginPath(); ctx.moveTo(w.x*S,w.y*S); ctx.lineTo((w.x+ux*5)*S,(w.y+uy*5)*S);
  ctx.strokeStyle='rgba(255,255,255,.7)'; ctx.lineWidth=2; ctx.stroke();
  ctx.beginPath(); ctx.moveTo(w.x*S,w.y*S); ctx.lineTo((w.x-ux*3)*S,(w.y-uy*3)*S);
  ctx.strokeStyle='rgba(255,0,0,.8)'; ctx.lineWidth=3; ctx.stroke();
  
  // 绘制置球点
  const marker = $('spotMarker');
  marker.style.display = 'block';
  marker.style.left = (spotX * S - 3) + 'px';
  marker.style.top = (spotY * S - 3) + 'px';
};

const draw=()=>{if(needBg)drawBg(); if(needTraj)drawTrajLayer();
const w=canvas.clientWidth,h=canvas.clientHeight;
ctx.clearRect(0,0,w,h); ctx.drawImage(bg,0,0,w,h); ctx.drawImage(traj,0,0,w,h);
drawBalls(); drawAim();
};

let runTrajEnabled=false,runTraj=[];
const enableRunTraj=()=>{
  runTrajEnabled=true; runTraj=Array(balls.length).fill(null);
  const moving=new Set();
  for(let i=0;i<balls.length;i++) if(!balls[i].p&&Math.hypot(balls[i].vx,balls[i].vy)>STOP_V) moving.add(i);
  const t=simPred({includeAim:false,recordSet:moving,sample:2});
  moving.forEach(i=>runTraj[i]=t[i]); needTraj=1;
};
const updateRunTraj=dirty=>{if(!showRunTraj||!runTrajEnabled||!dirty.size) return;
  const t=simPred({includeAim:false,recordSet:dirty,sample:2}); dirty.forEach(i=>runTraj[i]=t[i]); needTraj=1;
};
const disableRunTraj=()=>{runTrajEnabled=false;runTraj=[];needTraj=1;};

const tick=()=>{
  if(!running) return;
  const dirty=new Set();
  for(let i=0;i<balls.length;i++){const b=balls[i]; if(b.p) continue; if(stepBall(b)){b.ccr++;dirty.add(i);}}
  for(let i=0;i<balls.length;i++)for(let j=i+1;j<balls.length;j++){
    if(collide(balls[i],balls[j])){balls[i].ccr++;balls[j].ccr++;dirty.add(i);dirty.add(j);}
  }

  checkPots(true);
  if(checkCueScratch(true)) dirty.add(0);
  if(dirty.size) updateRunTraj(dirty);

  updatePotAnims(DT);

  simT+=DT; $('timeCounter').textContent=simT.toFixed(2);

  const onlyWhiteLeft=balls.length>0 && balls.every(b=>b.p||b.w);
  if(onlyWhiteLeft && !onlyWhiteTimer) onlyWhiteTimer=0;
  if(onlyWhiteTimer!==null){
    onlyWhiteTimer+=DT;
    if(onlyWhiteTimer>=4.0){running=false;disableRunTraj();aimLocked=false;setFine(0);onlyWhiteTimer=null;init();requestDraw();return;}
  }

  const stopped=balls.every(b=>b.p||Math.hypot(b.vx,b.vy)<STOP_V);
  if(stopped){
    finishShotCommon();
    const reds=balls.slice(1);
    if(reds.every(b=>b.p)) {
      potted = 0; // 重置计数器
      $('pottedCount').textContent = potted;
      setTimeout(init,1000);
    }
    return;
  }
  requestDraw(); requestAnimationFrame(tick);
};

const smart={running:false,cancel:false};
const setSmartUI=on=>{smart.running=on;$('smartProgressWrap').classList.toggle('show',on);$('smartAimStatus').classList.toggle('show',on);
$('stopBtn').classList.toggle('disabled',on);$('resetBtn').classList.toggle('disabled',on);};

function buildBase(){
  const n=balls.length;
  const bx=new Float64Array(n),by=new Float64Array(n),bvx=new Float64Array(n),bvy=new Float64Array(n),br=new Float64Array(n),bm=new Float64Array(n),bp=new Uint8Array(n),bw=new Uint8Array(n);
  let wi=0;
  for(let i=0;i<n;i++){
    const b=balls[i];
    bx[i]=b.x;by[i]=b.y;bvx[i]=b.vx;bvy[i]=b.vy;br[i]=R;bm[i]=b.m;bp[i]=b.p?1:0;bw[i]=b.w?1:0;
    if(b.w)wi=i;
  }
  const pi=[],pj=[]; for(let i=0;i<n;i++)for(let j=i+1;j<n;j++){pi.push(i);pj.push(j);}
  return{n,wi,bx,by,bvx,bvy,br,bm,bp,bw,pi,pj};
}

function evalAngle(base,deg){
  const {n,wi,pi,pj}=base;
  const x=new Float64Array(n),y=new Float64Array(n),vx=new Float64Array(n),vy=new Float64Array(n),p=new Uint8Array(n);
  x.set(base.bx);y.set(base.by);vx.set(base.bvx);vy.set(base.bvy);p.set(base.bp);
  for(let i=0;i<n;i++){if(p[i])continue;if(Math.hypot(vx[i],vy[i])<STOP_V){vx[i]=0;vy[i]=0;}}
  if(!p[wi] && Math.hypot(vx[wi],vy[wi])<STOP_V){
    const dx=aimX-x[wi],dy=aimY-y[wi],d=Math.hypot(dx,dy);
    if(d>EPS){const a=Math.atan2(dy,dx)+deg*Math.PI/180; vx[wi]=v0*Math.cos(a);vy[wi]=v0*Math.sin(a);}
  }

  const steps=Math.max(1,Math.floor(smartPredT/DT));
  const blf=(100-lossB)/100,elf=(100-lossC)/100;
  const initP=new Uint8Array(n); initP.set(p);
  let pot=0,last=0,scratched=false;

  for(let step=0;step<steps;step++){
    let any=0; for(let i=0;i<n;i++) if(!p[i]&&Math.hypot(vx[i],vy[i])>=STOP_V){any=1;break;} if(!any) break;

    for(let i=0;i<n;i++){
      if(p[i]) continue;
      const s=Math.hypot(vx[i],vy[i]);
      if(s>EPS){const ns=Math.max(0,s-fric*DT),k=ns/s;vx[i]*=k;vy[i]*=k;if(Math.hypot(vx[i],vy[i])<STOP_V){vx[i]=0;vy[i]=0;}}
      x[i]+=vx[i]*DT; y[i]+=vy[i]*DT;
      if(x[i]-base.br[i]<L){x[i]=L+base.br[i];vx[i]=-vx[i]*blf;} else if(x[i]+base.br[i]>RR){x[i]=RR-base.br[i];vx[i]=-vx[i]*blf;}
      if(y[i]-base.br[i]<T){y[i]=T+base.br[i];vy[i]=-vy[i]*blf;} else if(y[i]+base.br[i]>BB){y[i]=BB-base.br[i];vy[i]=-vy[i]*blf;}
    }

    for(let k=0;k<pi.length;k++){
      const i=pi[k],j=pj[k];
      if(p[i]||p[j]) continue;
      const dx=x[j]-x[i],dy=y[j]-y[i],md=base.br[i]+base.br[j],d2=dx*dx+dy*dy;
      if(d2>=md*md||d2<EPS) continue;
      const d=Math.sqrt(d2),nx=dx/d,ny=dy/d,tx=-ny,ty=nx;
      const v1n=vx[i]*nx+vy[i]*ny,v1t=vx[i]*tx+vy[i]*ty,v2n=vx[j]*nx+vy[j]*ny,v2t=vx[j]*tx+vy[j]*ty;
      const m1=base.bm[i],m2=base.bm[j];
      const v1n2=(v1n*(m1-m2)+2*m2*v2n)/(m1+m2),v2n2=(v2n*(m2-m1)+2*m1*v1n)/(m1+m2);
      vx[i]=(v1n2*nx+v1t*tx)*elf;vy[i]=(v1n2*ny+v1t*ty)*elf;
      vx[j]=(v2n2*nx+v2t*tx)*elf;vy[j]=(v2n2*ny+v2t*ty)*elf;
      const ov=(md-d)/2;x[i]-=ov*nx;y[i]-=ov*ny;x[j]+=ov*nx;y[j]+=ov*ny;
    }

    const t=(step+1)*DT;

    if(!p[wi]) for(const pk of pockets){ if(inPocket(pk,x[wi],y[wi],base.br[wi],vx[wi],vy[wi])){scratched=true;p[wi]=1;break;} }
    if(scratched) break;

    for(let i=0;i<n;i++){
      if(p[i]||i===wi) continue;
      for(const pk of pockets){
        if(inPocket(pk,x[i],y[i],base.br[i],vx[i],vy[i])){
          p[i]=1;
          if(!initP[i]){pot++; if(t>last) last=t;}
          break;
        }
      }
    }
  }
  return{pot,last,scratched};
}

async function smartAim(){
  if(running||smart.running) return;
  const w=balls[0]; if(!w||w.p) return;
  if(shotAngle(w,0)==null) return;

  smart.cancel=false; setSmartUI(true);
  const dis=['angleFineTune','speedControl','massControl','frictionControl','collisionLossControl','boundaryLossControl'];
  dis.forEach(id=>$(id).disabled=true);

  const total=2001;
  $('smartProgress').max=total; $('smartProgress').value=0; $('smartProgressText').textContent='0%';

  const base=buildBase();
  let best=0,bestPot=-1,bestT=1e9,sawNonScratch=false,sawNonScratchPot=false;

  for(let idx=0;idx<total&&!smart.cancel;){
    const t0=performance.now();
    for(let batch=0;idx<total&&batch<120;batch++,idx++){
      const deg=-1+idx*.001,r=evalAngle(base,deg);
      if(r.scratched) continue;
      sawNonScratch=true; if(r.pot>0) sawNonScratchPot=true;
      if(r.pot>bestPot || (r.pot===bestPot && r.last<bestT)){bestPot=r.pot;bestT=r.last;best=deg;}
      if(performance.now()-t0>10) break;
    }
    $('smartProgress').value=idx;
    $('smartProgressText').textContent=Math.floor(idx/total*100)+'%';
    await new Promise(requestAnimationFrame);
  }

  setSmartUI(false); dis.forEach(id=>$(id).disabled=false);
  if(smart.cancel) return;
  if(!sawNonScratch || !sawNonScratchPot) best=0;
  setFine(best); aimLocked=true; setTimeout(shoot,300);
}

const shoot=()=>{
  if(running||smart.running) return;
  const w=balls[0]; if(!w||w.p) return;
  const ang=shotAngle(w); if(ang==null) return;

  cueScratchedThisShot=false;
  w.vx=v0*Math.cos(ang); w.vy=v0*Math.sin(ang);
  balls.forEach(b=>b.ccr=0);
  running=true;
  showRunTraj?enableRunTraj():disableRunTraj();
  shotCount++; // 增加杆数统计
  ui();
  requestAnimationFrame(tick);
};

const stopAll=()=>{for(const b of balls){b.vx=0;b.vy=0;} finishShotCommon();};

// pointer
canvas.addEventListener('pointerdown',e=>{
  if(running||smart.running) return;
  if(e.pointerType!=='mouse') e.preventDefault();
  try{canvas.setPointerCapture(e.pointerId);}catch{}
  aiming=true; aimLocked=false;
  const p=toWorld(e); aimX=p.x; aimY=p.y; needTraj=1; requestDraw();
},{passive:false});

canvas.addEventListener('pointermove',e=>{
  if(running||smart.running) return;
  if(e.pointerType!=='mouse') e.preventDefault();
  if(aimLocked&&!aiming) return;
  const p=toWorld(e); aimX=p.x; aimY=p.y; needTraj=1; requestDraw();
},{passive:false});

canvas.addEventListener('pointerup',e=>{
  if(running||smart.running) return;
  if(e.pointerType!=='mouse') e.preventDefault();
  aiming=false; aimLocked=true; smartAim();
},{passive:false});
canvas.addEventListener('pointercancel',()=>{aiming=false;},{passive:false});

// controls
$('stopBtn').addEventListener('click',stopAll);
$('resetBtn').addEventListener('click',init);
$('speedControl').addEventListener('input',e=>{v0=+e.target.value;ui();needTraj=1;requestDraw();});
$('massControl').addEventListener('input',e=>{mw=linearToLog(+e.target.value);balls[0].m=mw;ui();needTraj=1;requestDraw();});
$('collisionLossControl').addEventListener('input',e=>{lossC=+e.target.value|0;ui();needTraj=1;requestDraw();});
$('frictionControl').addEventListener('input',e=>{fric=+e.target.value;ui();needTraj=1;requestDraw();});
$('boundaryLossControl').addEventListener('input',e=>{lossB=+e.target.value|0;ui();needTraj=1;requestDraw();});
$('predictionTimeControl').addEventListener('input',e=>{smartPredT=+e.target.value|0;ui();});
$('increaseCollisionsBtn').addEventListener('click',()=>{if(maxCol<10){maxCol++;ui();if(running&&showRunTraj)enableRunTraj();needTraj=1;requestDraw();}});
$('decreaseCollisionsBtn').addEventListener('click',()=>{if(maxCol>0){maxCol--;ui();if(running&&showRunTraj)enableRunTraj();needTraj=1;requestDraw();}});
$('increasePocketSizeBtn').addEventListener('click',()=>{if(pocketSize<1){pocketSize=Math.min(1,pocketSize+.05);makePockets();ui();needBg=needTraj=1;requestDraw();}});
$('decreasePocketSizeBtn').addEventListener('click',()=>{if(pocketSize>.4){pocketSize=Math.max(.4,pocketSize-.05);makePockets();ui();needBg=needTraj=1;requestDraw();}});
$('showTrajectoryDuringSimulation').addEventListener('change',e=>{showRunTraj=e.target.checked;if(running)showRunTraj?enableRunTraj():disableRunTraj();needTraj=1;requestDraw();});
$('angleFineTune').addEventListener('input',e=>setFine(+e.target.value));

// 新增布局按钮事件监听器
$('layout4Btn').addEventListener('click', () => {
  currentLayout = '4';
  spotX = 2 + (Math.random()-0.5)*0.5;
  spotY = H/2 + (Math.random()-0.5)*0.5;
  init();
});
$('layout9Btn').addEventListener('click', () => {
  currentLayout = '9';
  spotX = 2 + (Math.random()-0.5)*0.5;
  spotY = H/2 + (Math.random()-0.5)*0.5;
  init();
});
$('layout10Btn').addEventListener('click', () => {
  currentLayout = '10';
  spotX = 2 + (Math.random()-0.5)*0.5;
  spotY = H/2 + (Math.random()-0.5)*0.5;
  init();
});
$('layout15Btn').addEventListener('click', () => {
  currentLayout = '15';
  spotX = 2 + (Math.random()-0.5)*0.5;
  spotY = H/2 + (Math.random()-0.5)*0.5;
  init();
});

// 展开/折叠功能
window.toggleSection = function(sectionId) {
  const content = $(sectionId + '-content');
  const icon = $(sectionId + '-icon');
  content.classList.toggle('show');
  icon.classList.toggle('rotated');
  
  // 触发重绘以适应内容高度变化
  setTimeout(() => {
    const sidePanel = $('sidePanel');
    sidePanel.style.overflow = 'hidden';
    setTimeout(() => {
      sidePanel.style.overflow = '';
    }, 100);
  }, 0);
};

// 初始化时折叠所有部分
document.addEventListener('DOMContentLoaded', function() {
  ['physics', 'prediction', 'table'].forEach(section => {
    const content = $(section + '-content');
    const icon = $(section + '-icon');
    if (content && icon) {
      content.classList.remove('show');
      icon.classList.remove('rotated');
    }
  });
});

// resize
new ResizeObserver(resize).observe(canvas);
window.addEventListener('orientationchange',resize);
window.addEventListener('resize',resize);

ui(); init(); resize();
})();
</script>
</body>
</html>
