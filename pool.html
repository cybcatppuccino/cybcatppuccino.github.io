<!DOCTYPE html><html lang="zh-CN"><head>
<meta charset="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>台球狗运模拟器</title>
<style>
:root{--bg1:#1a2a6c;--bg2:#b21f1f;--felt:#27ae60;--wood:#8b4513;--panel-bg:rgba(0,0,0,.85);--control-bg:rgba(0,0,0,.7)}
*{box-sizing:border-box}body{font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;margin:0;padding:15px;min-height:100vh;color:#fff;background:linear-gradient(135deg,var(--bg1),var(--bg2),var(--bg1));display:flex;flex-direction:column;align-items:center;gap:12px;overflow-x:hidden}
h1{margin:0 0 6px;text-shadow:0 2px 4px rgba(0,0,0,.5);font-size:22px;text-align:center}
.container{width:100%;max-width:1200px;display:flex;flex-direction:column;gap:14px}
.content-wrapper{display:flex;gap:15px;width:100%}@media (max-width:900px){.content-wrapper{flex-direction:column}}
.table-section{flex:1;display:flex;flex-direction:column;gap:15px}
.canvas-container{position:relative;border:3px solid var(--wood);border-radius:8px;background:var(--felt);box-shadow:0 8px 16px rgba(0,0,0,.5);overflow:hidden;cursor:crosshair;touch-action:none}
canvas{display:block;width:100%;aspect-ratio:2/1;height:auto;background:var(--felt);touch-action:none}
.controls-below{background:var(--control-bg);border-radius:10px;padding:12px;display:grid;grid-template-columns:1fr 1fr;gap:15px}
@media (max-width:600px){.controls-below{grid-template-columns:1fr}}
.control-group{display:flex;flex-direction:column;gap:8px}
.control-label{font-weight:700;font-size:14px;display:flex;justify-content:space-between}
.control-value{color:#4ecdc4;min-width:50px;text-align:right}
input[type="range"]{width:100%;height:8px;border-radius:4px;background:#333;outline:none}
.side{width:320px;background:var(--panel-bg);border-radius:10px;padding:14px;box-shadow:0 4px 8px rgba(0,0,0,.3);display:flex;flex-direction:column;gap:12px;flex-shrink:0}
@media (max-width:900px){.side{width:100%}}
.grid{display:grid;grid-template-columns:1fr;gap:10px;flex:1}
.row2{display:grid;grid-template-columns:1fr 1fr;gap:10px}@media (max-width:600px){.row2{grid-template-columns:1fr}}
label{display:block;margin-bottom:6px;font-weight:800;font-size:13px}
.btns{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;margin-top:6px}
button{padding:10px 14px;font-size:14px;font-weight:900;border:none;border-radius:6px;cursor:pointer;color:#fff;transition:all .2s;box-shadow:0 4px 6px rgba(0,0,0,.2);background:linear-gradient(to bottom,#3498db,#2980b9);flex:1;min-width:100px}
button:hover{filter:brightness(1.07);transform:translateY(-1px);box-shadow:0 6px 10px rgba(0,0,0,.28)}
button:active{transform:translateY(1px)}
#resetBtn{background:linear-gradient(to bottom,#e74c3c,#c0392b)}#stopBtn{background:linear-gradient(to bottom,#95a5a6,#7f8c8d)}
.small{font-size:12px;opacity:.9;text-align:center}
.prediction-controls{display:flex;align-items:center;gap:8px;justify-content:center}
.chip{background:rgba(255,255,255,.09);padding:8px 10px;border-radius:10px}
.info-panel{background:var(--panel-bg);padding:12px;border-radius:8px;text-align:center;font-size:13px}
.stats{display:flex;gap:10px;justify-content:space-around;flex-wrap:wrap;margin-top:8px}
.stat-item{background:rgba(0,0,0,.5);padding:7px 12px;border-radius:6px}
.progress-wrap{display:none;gap:8px;align-items:center}.progress-wrap.show{display:flex}
progress{width:100%;height:14px}
.disabled{opacity:.55;pointer-events:none}
.smart-aim-status{text-align:center;padding:8px;background:rgba(46,204,113,.2);border-radius:6px;display:none}
.smart-aim-status.show{display:block}
</style></head><body>
<h1>台球好运模拟器</h1>

<div class="container"><div class="content-wrapper">
  <div class="table-section">
    <div class="canvas-container"><canvas id="poolTable" width="800" height="400"></canvas></div>
    <div class="controls-below">
      <div class="control-group">
        <div class="control-label"><span>预测时间:</span><span id="predictionTimeValue" class="control-value">15</span>s</div>
        <input type="range" id="predictionTimeControl" min="5" max="50" value="15" step="5"/>
      </div>
      <div class="control-group">
        <div class="control-label"><span>角度微调 (±1°):</span><span id="angleFineTuneValue" class="control-value">0.000</span>°</div>
        <input type="range" id="angleFineTune" min="-1" max="1" value="0" step="0.001"/>
      </div>
    </div>
  </div>

  <div class="side" id="sidePanel"><div class="grid">
    <div class="row2">
      <div class="chip">
        <label>红球入袋数: <span id="pottedCount">0</span></label>
        <div class="small">模拟时间: <span id="timeCounter">0.00</span>s</div>
      </div>
      <div class="chip">
        <label><input type="checkbox" id="showTrajectoryDuringSimulation" style="width:auto;margin-right:8px;" checked/>运行时显示轨迹</label>
      </div>
    </div>

    <div class="chip">
      <label for="speedControl">白球初始速度: <span id="speedValue">12.00</span> 单位/秒</label>
      <input type="range" id="speedControl" min="0.1" max="30" value="12" step="0.01"/>
    </div>

    <div class="btns"><button id="stopBtn">停止所有球</button><button id="resetBtn">重新开始</button></div>

    <div class="progress-wrap" id="smartProgressWrap">
      <progress id="smartProgress" value="0" max="2001"></progress>
      <div class="small" style="min-width:96px;text-align:right;"><span id="smartProgressText">0%</span></div>
    </div>
    <div class="smart-aim-status" id="smartAimStatus">正在帮你积攒狗运</div>

    <div class="row2">
      <div class="chip">
        <label for="massControl">白球质量: <span id="massValue">1.0</span></label>
        <input type="range" id="massControl" min="-1" max="0.5" value="0" step="0.01"/>
      </div>
      <div class="chip">
        <label for="frictionControl">桌面摩擦力: <span id="frictionValue">0.30</span></label>
        <input type="range" id="frictionControl" min="0" max="1" value="0.3" step="0.01"/>
      </div>
    </div>

    <div class="row2">
      <div class="chip">
        <label for="collisionLossControl">碰撞能量损失: <span id="collisionLossValue">5</span>%</label>
        <input type="range" id="collisionLossControl" min="0" max="20" value="5" step="0.1"/>
      </div>
      <div class="chip">
        <label for="boundaryLossControl">边界能量损失: <span id="boundaryLossValue">5</span>%</label>
        <input type="range" id="boundaryLossControl" min="0" max="20" value="5" step="0.1"/>
      </div>
    </div>

    <div class="chip">
      <label>预测碰撞次数: <span id="maxCollisionsValue">2</span></label>
      <div class="prediction-controls"><button id="decreaseCollisionsBtn">-</button><span id="maxCollisionsDisplay">2</span><button id="increaseCollisionsBtn">+</button></div>
    </div>

    <div class="chip">
      <label>袋口大小: <span id="pocketSizeValue">0.60</span></label>
      <div class="prediction-controls"><button id="decreasePocketSizeBtn">-</button><span id="pocketSizeDisplay">0.60</span><button id="increasePocketSizeBtn">+</button></div>
    </div>
  </div></div>
</div>

<div class="info-panel"><div class="stats"><div class="stat-item">说明：瞎蒙一杆就行。</div></div></div>
</div>

<script>
(()=>{const $=id=>document.getElementById(id),canvas=$('poolTable'),ctx=canvas.getContext('2d',{alpha:false,desynchronized:true});
const W=20,H=10,R=.25,RED_M=1,FPS=60,DT=1/FPS,STOP_V=.01,EPS=1e-9;
const COLORS=['#E74C3C','#3498DB','#2ECC71','#F1C40F','#9B59B6','#1ABC9C','#E67E22','#34495E','#FF6B6B','#4ECDC4'];
const hex2rgb=h=>[parseInt(h.slice(1,3),16),parseInt(h.slice(3,5),16),parseInt(h.slice(5,7),16)];
let v0=12,mw=1,lossC=5,fric=.3,lossB=5,smartPredT=15,maxCol=2,pocketSize=.6;
let balls=[],pockets=[],running=false,showRunTraj=true,potted=0,simT=0,aimX=0,aimY=0,aimLocked=false,aiming=false,angFine=0,raf=0,needTraj=true,needBg=true;
const bg=document.createElement('canvas'),bgc=bg.getContext('2d',{alpha:false});
const traj=document.createElement('canvas'),tctx=traj.getContext('2d',{alpha:true});
let S=40;
const linearToLog=v=>v>=0?1+v*9:Math.pow(10,v);
const setFine=v=>{angFine=v;$('angleFineTune').value=v;$('angleFineTuneValue').textContent=v.toFixed(3);needTraj=1;requestDraw();};
const ui=()=>{$('speedValue').textContent=v0.toFixed(2);$('massValue').textContent=mw.toFixed(1);$('collisionLossValue').textContent=lossC;
$('frictionValue').textContent=fric.toFixed(2);$('boundaryLossValue').textContent=lossB;$('predictionTimeValue').textContent=smartPredT;
$('maxCollisionsValue').textContent=maxCol;$('maxCollisionsDisplay').textContent=maxCol;$('pocketSizeValue').textContent=pocketSize.toFixed(2);
$('pocketSizeDisplay').textContent=pocketSize.toFixed(2);$('pottedCount').textContent=potted;$('timeCounter').textContent=simT.toFixed(2);
$('showTrajectoryDuringSimulation').checked=showRunTraj;};
const toWorld=e=>{const r=canvas.getBoundingClientRect();
const ox=(typeof e.offsetX==='number')?e.offsetX:(e.clientX-r.left),oy=(typeof e.offsetY==='number')?e.offsetY:(e.clientY-r.top);
const x=ox/r.width*W,y=oy/r.height*H;return{x:Math.min(W,Math.max(0,x)),y:Math.min(H,Math.max(0,y))};};
const shotAngle=(w,f=angFine)=>{const dx=aimX-w.x,dy=aimY-w.y;if(Math.hypot(dx,dy)<EPS)return null;return Math.atan2(dy,dx)+f*Math.PI/180;};
const requestDraw=()=>{if(raf)return;raf=requestAnimationFrame(()=>{raf=0;draw();});};

const makeBall=(x,y,color,isWhite=false)=>({x,y,vx:0,vy:0,r:R,m:isWhite?mw:RED_M,c:color,rgb:isWhite?[255,255,255]:hex2rgb(color),w:isWhite,p:0,ccr:0});
const makePockets=()=>{const r=pocketSize*.5;pockets=[{x:0,y:0,r},{x:W,y:0,r},{x:0,y:H,r},{x:W,y:H,r},{x:W/2,y:0,r},{x:W/2,y:H,r}];};
const init=()=>{running=false;potted=0;simT=0;aimLocked=false;aiming=false;setFine(0);makePockets();balls=[];
balls.push(makeBall(2,H/2,'#fff',true));let k=0,sx=15,sy=H/2;
for(let row=0;row<4;row++)for(let col=0;col<=row;col++){if(balls.length>10)break;const hs=R*2.2,vs=R*2.0;
balls.push(makeBall(sx+row*hs+(Math.random()-.5)*.1,sy+(col-row/2)*vs+(Math.random()-.5)*.1,COLORS[k++%COLORS.length]));}
balls.forEach(b=>b.ccr=0);
aimX=balls[0].x+5;aimY=balls[0].y;needBg=needTraj=1;ui();requestDraw();};

const stepBall=b=>{if(b.p)return 0;const s=Math.hypot(b.vx,b.vy);if(s>EPS){const ns=Math.max(0,s-fric*DT),k=ns/s;b.vx*=k;b.vy*=k;}
b.x+=b.vx*DT;b.y+=b.vy*DT;const blf=(100-lossB)/100;let hit=0;
if(b.x-b.r<0){b.x=b.r;b.vx=-b.vx*blf;hit=1;}else if(b.x+b.r>W){b.x=W-b.r;b.vx=-b.vx*blf;hit=1;}
if(b.y-b.r<0){b.y=b.r;b.vy=-b.vy*blf;hit=1;}else if(b.y+b.r>H){b.y=H-b.r;b.vy=-b.vy*blf;hit=1;}
return hit;};
const collide=(a,b)=>{if(a.p||b.p)return 0;const dx=b.x-a.x,dy=b.y-a.y,md=a.r+b.r,d2=dx*dx+dy*dy;if(d2>=md*md||d2<EPS)return 0;
const d=Math.sqrt(d2),nx=dx/d,ny=dy/d,tx=-ny,ty=nx;
const v1n=a.vx*nx+a.vy*ny,v1t=a.vx*tx+a.vy*ty,v2n=b.vx*nx+b.vy*ny,v2t=b.vx*tx+b.vy*ty,m1=a.m,m2=b.m;
const v1n2=(v1n*(m1-m2)+2*m2*v2n)/(m1+m2),v2n2=(v2n*(m2-m1)+2*m1*v1n)/(m1+m2),elf=(100-lossC)/100;
a.vx=(v1n2*nx+v1t*tx)*elf;a.vy=(v1n2*ny+v1t*ty)*elf;b.vx=(v2n2*nx+v2t*tx)*elf;b.vy=(v2n2*ny+v2t*ty)*elf;
const ov=(md-d)/2;a.x-=ov*nx;a.y-=ov*ny;b.x+=ov*nx;b.y+=ov*ny;return 1;};
const checkPots=countUI=>{for(const b of balls){if(b.p||b.w)continue;for(const pk of pockets){const dx=b.x-pk.x,dy=b.y-pk.y,rr=pk.r+b.r;
if(dx*dx+dy*dy<rr*rr){b.p=1;if(countUI){potted++;$('pottedCount').textContent=potted;}break;}}}};

// 预测：滑动窗口（从当前 ccr 开始，显示接下来 maxCol 次碰撞对应的轨迹段）
function simPred({includeAim,recordSet=null,sample=1,maxSteps=60000}){
  const n=balls.length;
  const x=new Float64Array(n),y=new Float64Array(n),vx=new Float64Array(n),vy=new Float64Array(n);
  const r=new Float64Array(n),m=new Float64Array(n),p=new Uint8Array(n),w=new Uint8Array(n),cc=new Uint16Array(n),start=new Uint16Array(n);
  let wi=-1;
  for(let i=0;i<n;i++){const b=balls[i];
    x[i]=b.x;y[i]=b.y;vx[i]=b.vx;vy[i]=b.vy;r[i]=b.r;m[i]=b.m;p[i]=b.p;w[i]=b.w?1:0;cc[i]=start[i]=b.ccr||0;if(b.w)wi=i;
  }
  if(includeAim&&wi>=0&&!p[wi]&&Math.hypot(vx[wi],vy[wi])<0.001){
    const dx=aimX-x[wi],dy=aimY-y[wi],d=Math.hypot(dx,dy);
    if(d>EPS){const ang=Math.atan2(dy,dx)+angFine*Math.PI/180;vx[wi]=v0*Math.cos(ang);vy[wi]=v0*Math.sin(ang);}
  }
  const want=i=>!recordSet||recordSet.has(i);
  const trajArr=Array.from({length:n},(_,i)=>({pts:[],rgb:balls[i].rgb}));
  const blf=(100-lossB)/100,elf=(100-lossC)/100;

  for(let step=0;step<maxSteps;step++){
    let any=0; for(let i=0;i<n;i++) if(!p[i]&&Math.hypot(vx[i],vy[i])>=STOP_V){any=1;break;} if(!any) break;

    if(step%sample===0) for(let i=0;i<n;i++) if(want(i)&&!p[i]&&cc[i]<=start[i]+maxCol) trajArr[i].pts.push(x[i],y[i]);

    for(let i=0;i<n;i++){
      if(p[i]) continue;
      const s=Math.hypot(vx[i],vy[i]);
      if(s>EPS){const ns=Math.max(0,s-fric*DT),k=ns/s;vx[i]*=k;vy[i]*=k;}
      x[i]+=vx[i]*DT;y[i]+=vy[i]*DT;
      let hit=0;
      if(x[i]-r[i]<0){x[i]=r[i];vx[i]=-vx[i]*blf;hit=1;}else if(x[i]+r[i]>W){x[i]=W-r[i];vx[i]=-vx[i]*blf;hit=1;}
      if(y[i]-r[i]<0){y[i]=r[i];vy[i]=-vy[i]*blf;hit=1;}else if(y[i]+r[i]>H){y[i]=H-r[i];vy[i]=-vy[i]*blf;hit=1;}
      if(hit) cc[i]++;
    }

    for(let i=0;i<n;i++)for(let j=i+1;j<n;j++){
      if(p[i]||p[j]) continue;
      const dx=x[j]-x[i],dy=y[j]-y[i],md=r[i]+r[j],d2=dx*dx+dy*dy;
      if(d2>=md*md||d2<EPS) continue;
      const d=Math.sqrt(d2),nx=dx/d,ny=dy/d,tx=-ny,ty=nx;
      const v1n=vx[i]*nx+vy[i]*ny,v1t=vx[i]*tx+vy[i]*ty,v2n=vx[j]*nx+vy[j]*ny,v2t=vx[j]*tx+vy[j]*ty;
      const m1=m[i],m2=m[j];
      const v1n2=(v1n*(m1-m2)+2*m2*v2n)/(m1+m2),v2n2=(v2n*(m2-m1)+2*m1*v1n)/(m1+m2);
      vx[i]=(v1n2*nx+v1t*tx)*elf;vy[i]=(v1n2*ny+v1t*ty)*elf;
      vx[j]=(v2n2*nx+v2t*tx)*elf;vy[j]=(v2n2*ny+v2t*ty)*elf;
      const ov=(md-d)/2;x[i]-=ov*nx;y[i]-=ov*ny;x[j]+=ov*nx;y[j]+=ov*ny;
      cc[i]++;cc[j]++;
    }

    for(let i=0;i<n;i++){
      if(p[i]||w[i]) continue;
      for(const pk of pockets){
        const dx=x[i]-pk.x,dy=y[i]-pk.y,rr=pk.r+r[i];
        if(dx*dx+dy*dy<rr*rr){p[i]=1;break;}
      }
    }
  }
  return trajArr;
}

const resize=()=>{const dpr=Math.min(2,window.devicePixelRatio||1),w=canvas.clientWidth||800,h=w*(H/W);
canvas.style.height=h+'px';const pxW=Math.round(w*dpr),pxH=Math.round(h*dpr);
if(canvas.width===pxW&&canvas.height===pxH)return;canvas.width=pxW;canvas.height=pxH;bg.width=pxW;bg.height=pxH;traj.width=pxW;traj.height=pxH;
ctx.setTransform(dpr,0,0,dpr,0,0);bgc.setTransform(dpr,0,0,dpr,0,0);tctx.setTransform(dpr,0,0,dpr,0,0);S=w/W;needBg=needTraj=1;requestDraw();};
const drawBg=()=>{const w=canvas.clientWidth,h=canvas.clientHeight;bgc.clearRect(0,0,w,h);
bgc.fillStyle='#27ae60';bgc.fillRect(0,0,w,h);bgc.strokeStyle='#8b4513';bgc.lineWidth=6;bgc.strokeRect(0,0,w,h);
bgc.strokeStyle='#1a5c30';bgc.lineWidth=2;bgc.strokeRect(R*S,R*S,(W-2*R)*S,(H-2*R)*S);
for(const pk of pockets){bgc.beginPath();bgc.arc(pk.x*S,pk.y*S,pk.r*S,0,Math.PI*2);bgc.fillStyle='#000';bgc.fill();
bgc.beginPath();bgc.arc(pk.x*S,pk.y*S,pk.r*S*.7,0,Math.PI*2);bgc.fillStyle='#333';bgc.fill();}needBg=0;};
const strokePoly=(pts,rgb,dynamic)=>{if(!pts||pts.length<4)return;const chunks=dynamic?10:1,n=pts.length/2;
for(let c=0;c<chunks;c++){const a0=c/chunks,a1=(c+1)/chunks,i0=Math.floor(a0*(n-1)),i1=Math.max(i0+1,Math.floor(a1*(n-1)));
const alpha=dynamic?Math.max(.12,1-a0*.9):.65;tctx.strokeStyle=`rgba(${rgb[0]},${rgb[1]},${rgb[2]},${alpha})`;tctx.lineWidth=2;
tctx.beginPath();tctx.moveTo(pts[i0*2]*S,pts[i0*2+1]*S);for(let i=i0+1;i<=i1;i++)tctx.lineTo(pts[i*2]*S,pts[i*2+1]*S);tctx.stroke();}};
const drawTrajLayer=()=>{const w=canvas.clientWidth,h=canvas.clientHeight;tctx.clearRect(0,0,w,h);
if(running){if(showRunTraj&&runTrajEnabled)for(let i=0;i<runTraj.length;i++){const t=runTraj[i];if(t&&balls[i]&&!balls[i].p)strokePoly(t.pts,t.rgb,false);}}
else{const t=simPred({includeAim:true,sample:1});for(let i=0;i<t.length;i++)if(!balls[i].p)strokePoly(t[i].pts,t[i].rgb,true);}needTraj=0;};
const drawBalls=()=>{for(const b of balls){if(b.p)continue;ctx.beginPath();ctx.arc(b.x*S,b.y*S,b.r*S,0,Math.PI*2);
ctx.fillStyle=b.w?'#fff':b.c;ctx.fill();ctx.strokeStyle='#000';ctx.lineWidth=1;ctx.stroke();
if(!b.w){ctx.beginPath();ctx.arc(b.x*S-b.r*S*.3,b.y*S-b.r*S*.3,b.r*S*.2,0,Math.PI*2);ctx.fillStyle='rgba(255,255,255,.9)';ctx.fill();}}};
const drawAim=()=>{if(running)return;const w=balls[0];if(!w||w.p)return;const ang=shotAngle(w);if(ang==null)return;
const ux=Math.cos(ang),uy=Math.sin(ang);ctx.beginPath();ctx.moveTo(w.x*S,w.y*S);ctx.lineTo((w.x+ux*5)*S,(w.y+uy*5)*S);
ctx.strokeStyle='rgba(255,255,255,.7)';ctx.lineWidth=2;ctx.stroke();ctx.beginPath();ctx.moveTo(w.x*S,w.y*S);ctx.lineTo((w.x-ux*3)*S,(w.y-uy*3)*S);
ctx.strokeStyle='rgba(255,0,0,.8)';ctx.lineWidth=3;ctx.stroke();};
const draw=()=>{if(needBg)drawBg();if(needTraj)drawTrajLayer();const w=canvas.clientWidth,h=canvas.clientHeight;
ctx.clearRect(0,0,w,h);ctx.drawImage(bg,0,0,w,h);ctx.drawImage(traj,0,0,w,h);drawBalls();drawAim();};

// 运行时轨迹：按碰撞滑窗更新（碰撞发生 -> 立刻重算并显示下一段 maxCol 次碰撞）
let runTrajEnabled=false,runTraj=[];
const enableRunTraj=()=>{
  runTrajEnabled=true; runTraj=Array(balls.length).fill(null);
  const moving=new Set(); for(let i=0;i<balls.length;i++) if(!balls[i].p&&Math.hypot(balls[i].vx,balls[i].vy)>STOP_V) moving.add(i);
  const t=simPred({includeAim:false,recordSet:moving,sample:2}); moving.forEach(i=>runTraj[i]=t[i]); needTraj=1;
};
const updateRunTraj=dirty=>{
  if(!showRunTraj||!runTrajEnabled||!dirty.size) return;
  const t=simPred({includeAim:false,recordSet:dirty,sample:2}); dirty.forEach(i=>runTraj[i]=t[i]); needTraj=1;
};
const disableRunTraj=()=>{runTrajEnabled=false;runTraj=[];needTraj=1;};

const tick=()=>{if(!running)return;
  const dirty=new Set();
  for(let i=0;i<balls.length;i++){const b=balls[i];if(b.p)continue;if(stepBall(b)){b.ccr++;dirty.add(i);}}
  for(let i=0;i<balls.length;i++)for(let j=i+1;j<balls.length;j++) if(collide(balls[i],balls[j])){balls[i].ccr++;balls[j].ccr++;dirty.add(i);dirty.add(j);}
  checkPots(true);
  if(dirty.size) updateRunTraj(dirty);
  simT+=DT;$('timeCounter').textContent=simT.toFixed(2);
  const stopped=balls.every(b=>b.p||Math.hypot(b.vx,b.vy)<STOP_V);
  if(stopped){running=false;disableRunTraj();aimLocked=false;setFine(0);const reds=balls.slice(1);if(reds.every(b=>b.p))setTimeout(init,1000);requestDraw();return;}
  requestDraw();requestAnimationFrame(tick);
};

const smart={running:false,cancel:false};
const setSmartUI=on=>{smart.running=on;$('smartProgressWrap').classList.toggle('show',on);$('smartAimStatus').classList.toggle('show',on);
$('stopBtn').classList.toggle('disabled',on);$('resetBtn').classList.toggle('disabled',on);};

function buildBase(){const n=balls.length;
const bx=new Float64Array(n),by=new Float64Array(n),bvx=new Float64Array(n),bvy=new Float64Array(n),br=new Float64Array(n),bm=new Float64Array(n),bp=new Uint8Array(n);
let wi=0;for(let i=0;i<n;i++){const b=balls[i];bx[i]=b.x;by[i]=b.y;bvx[i]=b.vx;bvy[i]=b.vy;br[i]=b.r;bm[i]=b.m;bp[i]=b.p?1:0;if(b.w)wi=i;}
const pi=[],pj=[];for(let i=0;i<n;i++)for(let j=i+1;j<n;j++){pi.push(i);pj.push(j);}return{n,wi,bx,by,bvx,bvy,br,bm,bp,pi,pj};}

function evalAngle(base,deg){
const {n,wi,pi,pj}=base;
const x=new Float64Array(n),y=new Float64Array(n),vx=new Float64Array(n),vy=new Float64Array(n),p=new Uint8Array(n);
x.set(base.bx);y.set(base.by);vx.set(base.bvx);vy.set(base.bvy);p.set(base.bp);

if(!p[wi]&&Math.hypot(vx[wi],vy[wi])<0.001){const dx=aimX-x[wi],dy=aimY-y[wi],d=Math.hypot(dx,dy);
if(d>EPS){const a=Math.atan2(dy,dx)+deg*Math.PI/180;vx[wi]=v0*Math.cos(a);vy[wi]=v0*Math.sin(a);}}

const steps=Math.max(1,Math.floor(smartPredT/DT)); // 预测时间：只影响智能枚举
const blf=(100-lossB)/100,elf=(100-lossC)/100;
const initP=new Uint8Array(n);initP.set(p);let pot=0,last=0;

for(let step=0;step<steps;step++){
  let any=0;for(let i=0;i<n;i++)if(!p[i]&&Math.hypot(vx[i],vy[i])>=STOP_V){any=1;break;}if(!any)break;
  for(let i=0;i<n;i++){if(p[i])continue;const s=Math.hypot(vx[i],vy[i]);
    if(s>EPS){const ns=Math.max(0,s-fric*DT),k=ns/s;vx[i]*=k;vy[i]*=k;}
    x[i]+=vx[i]*DT;y[i]+=vy[i]*DT;
    if(x[i]-base.br[i]<0){x[i]=base.br[i];vx[i]=-vx[i]*blf;}else if(x[i]+base.br[i]>W){x[i]=W-base.br[i];vx[i]=-vx[i]*blf;}
    if(y[i]-base.br[i]<0){y[i]=base.br[i];vy[i]=-vy[i]*blf;}else if(y[i]+base.br[i]>H){y[i]=H-base.br[i];vy[i]=-vy[i]*blf;}}
  for(let k=0;k<pi.length;k++){const i=pi[k],j=pj[k];if(p[i]||p[j])continue;
    const dx=x[j]-x[i],dy=y[j]-y[i],md=base.br[i]+base.br[j],d2=dx*dx+dy*dy;if(d2>=md*md||d2<EPS)continue;
    const d=Math.sqrt(d2),nx=dx/d,ny=dy/d,tx=-ny,ty=nx;
    const v1n=vx[i]*nx+vy[i]*ny,v1t=vx[i]*tx+vy[i]*ty,v2n=vx[j]*nx+vy[j]*ny,v2t=vx[j]*tx+vy[j]*ty;
    const m1=base.bm[i],m2=base.bm[j];
    const v1n2=(v1n*(m1-m2)+2*m2*v2n)/(m1+m2),v2n2=(v2n*(m2-m1)+2*m1*v1n)/(m1+m2);
    vx[i]=(v1n2*nx+v1t*tx)*elf;vy[i]=(v1n2*ny+v1t*ty)*elf;vx[j]=(v2n2*nx+v2t*tx)*elf;vy[j]=(v2n2*ny+v2t*ty)*elf;
    const ov=(md-d)/2;x[i]-=ov*nx;y[i]-=ov*ny;x[j]+=ov*nx;y[j]+=ov*ny;}
  const t=(step+1)*DT;
  for(let i=0;i<n;i++){if(p[i]||i===wi)continue;for(const pk of pockets){
    const dx=x[i]-pk.x,dy=y[i]-pk.y,rr=pk.r+base.br[i];
    if(dx*dx+dy*dy<rr*rr){p[i]=1;if(!initP[i]){pot++;if(t>last)last=t;}break;}}}
}
return{pot,last};}

async function smartAim(){
if(running||smart.running)return;const w=balls[0];if(!w||w.p)return;if(shotAngle(w,0)==null)return;
smart.cancel=false;setSmartUI(true);
const dis=['angleFineTune','speedControl','massControl','frictionControl','collisionLossControl','boundaryLossControl'];dis.forEach(id=>$(id).disabled=true);
const total=2001;$('smartProgress').max=total;$('smartProgress').value=0;$('smartProgressText').textContent='0%';
const base=buildBase();let best=0,bpot=-1,bt=1e9;
for(let idx=0;idx<total&&!smart.cancel;){
  const t0=performance.now();
  for(let batch=0;idx<total&&batch<120;batch++,idx++){
    const deg=-1+idx*.001,r=evalAngle(base,deg);
    if(r.pot>bpot||(r.pot===bpot&&r.last<bt)){bpot=r.pot;bt=r.last;best=deg;}
    if(performance.now()-t0>10)break;
  }
  $('smartProgress').value=idx;$('smartProgressText').textContent=Math.floor(idx/total*100)+'%';
  await new Promise(requestAnimationFrame);
}
setSmartUI(false);dis.forEach(id=>$(id).disabled=false);
if(!smart.cancel){setFine(best);aimLocked=true;setTimeout(shoot,300);}
}

const shoot=()=>{if(running||smart.running)return;const w=balls[0];if(!w||w.p)return;const ang=shotAngle(w);if(ang==null)return;
w.vx=v0*Math.cos(ang);w.vy=v0*Math.sin(ang);balls.forEach(b=>b.ccr=0);running=true;
showRunTraj?enableRunTraj():disableRunTraj();
requestAnimationFrame(tick);};

const stopAll=()=>{for(const b of balls){b.vx=0;b.vy=0;}running=false;disableRunTraj();aimLocked=false;setFine(0);requestDraw();};

// pointer：移动端更一致（preventDefault + 非passive move + offset优先）
canvas.addEventListener('pointerdown',e=>{if(running||smart.running)return;if(e.pointerType!=='mouse')e.preventDefault();
try{canvas.setPointerCapture(e.pointerId);}catch{}aiming=true;aimLocked=false;const p=toWorld(e);aimX=p.x;aimY=p.y;needTraj=1;requestDraw();
},{passive:false});
canvas.addEventListener('pointermove',e=>{if(running||smart.running)return;if(e.pointerType!=='mouse')e.preventDefault();
if(aimLocked&&!aiming)return;const p=toWorld(e);aimX=p.x;aimY=p.y;needTraj=1;requestDraw();
},{passive:false});
canvas.addEventListener('pointerup',e=>{if(running||smart.running)return;if(e.pointerType!=='mouse')e.preventDefault();
aiming=false;aimLocked=true;smartAim();
},{passive:false});
canvas.addEventListener('pointercancel',()=>{aiming=false;},{passive:false});

// controls
$('stopBtn').addEventListener('click',stopAll);$('resetBtn').addEventListener('click',init);
$('speedControl').addEventListener('input',e=>{v0=+e.target.value;ui();needTraj=1;requestDraw();});
$('massControl').addEventListener('input',e=>{mw=linearToLog(+e.target.value);balls[0].m=mw;ui();needTraj=1;requestDraw();});
$('collisionLossControl').addEventListener('input',e=>{lossC=+e.target.value|0;ui();needTraj=1;requestDraw();});
$('frictionControl').addEventListener('input',e=>{fric=+e.target.value;ui();needTraj=1;requestDraw();});
$('boundaryLossControl').addEventListener('input',e=>{lossB=+e.target.value|0;ui();needTraj=1;requestDraw();});
// 预测时间：只影响智能枚举（不触发轨迹重算）
$('predictionTimeControl').addEventListener('input',e=>{smartPredT=+e.target.value|0;ui();});
$('increaseCollisionsBtn').addEventListener('click',()=>{if(maxCol<10){maxCol++;ui();if(running&&showRunTraj)enableRunTraj();needTraj=1;requestDraw();}});
$('decreaseCollisionsBtn').addEventListener('click',()=>{if(maxCol>0){maxCol--;ui();if(running&&showRunTraj)enableRunTraj();needTraj=1;requestDraw();}});
$('increasePocketSizeBtn').addEventListener('click',()=>{if(pocketSize<1){pocketSize=Math.min(1,pocketSize+.05);makePockets();ui();needBg=needTraj=1;requestDraw();}});
$('decreasePocketSizeBtn').addEventListener('click',()=>{if(pocketSize>.1){pocketSize=Math.max(.1,pocketSize-.05);makePockets();ui();needBg=needTraj=1;requestDraw();}});
$('showTrajectoryDuringSimulation').addEventListener('change',e=>{showRunTraj=e.target.checked;if(running)showRunTraj?enableRunTraj():disableRunTraj();needTraj=1;requestDraw();});
$('angleFineTune').addEventListener('input',e=>setFine(+e.target.value));

// resize
new ResizeObserver(resize).observe(canvas);window.addEventListener('orientationchange',resize);window.addEventListener('resize',resize);
ui();init();resize();
})();</script></body></html>
