<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>å°çƒç‹—è¿æ¨¡æ‹Ÿå™¨</title>
  <style>
    :root{
      --bg1:#1a2a6c;
      --bg2:#b21f1f;
      --felt:#27ae60;
      --wood:#8b4513;
      --panel-bg:rgba(0,0,0,0.85);
      --control-bg:rgba(0,0,0,0.7);
      --confirm-green:#27ae60;
      --cancel-red:#e74c3c;
    }
    
    * { box-sizing: border-box; }
    
    body{
      font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;
      margin:0; padding:15px;
      min-height:100vh;
      color:#fff;
      background:linear-gradient(135deg,var(--bg1),var(--bg2),var(--bg1));
      display:flex; flex-direction:column; align-items:center; gap:12px;
      overflow-x: hidden;
    }
    
    h1{
      margin:0 0 6px; 
      text-shadow:0 2px 4px rgba(0,0,0,.5); 
      font-size:22px;
      text-align: center;
    }
    
    .container{
      width:100%;
      max-width: 1200px;
      display:flex; 
      flex-direction:column; 
      gap:14px;
    }
    
    .content-wrapper {
      display: flex;
      gap: 15px;
      width: 100%;
    }
    
    @media (max-width: 900px) {
      .content-wrapper { flex-direction: column; }
    }
    
    .table-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    .canvas-container{
      position:relative; 
      border:3px solid var(--wood); 
      border-radius:8px;
      background:var(--felt); 
      box-shadow:0 8px 16px rgba(0,0,0,.5);
      overflow:hidden; 
      cursor:crosshair;
    }
    
    canvas{
      display:block; 
      background:var(--felt);
      width: 100%;
      height: auto;
    }
    
    .controls-below {
      background: var(--control-bg);
      border-radius: 10px;
      padding: 12px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
    }
    
    @media (max-width: 600px) {
      .controls-below {
        grid-template-columns: 1fr;
      }
    }
    
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    .control-label {
      font-weight: bold;
      font-size: 14px;
      display: flex;
      justify-content: space-between;
    }
    
    .control-value {
      color: #4ecdc4;
      min-width: 50px;
      text-align: right;
    }
    
    input[type="range"] {
      width: 100%;
      height: 8px;
      border-radius: 4px;
      background: #333;
      outline: none;
    }
    
    .side{
      width: 320px;
      background:var(--panel-bg);
      border-radius:10px; 
      padding:14px;
      box-shadow:0 4px 8px rgba(0,0,0,.3);
      display: flex;
      flex-direction: column;
      gap: 12px;
      flex-shrink: 0;
    }
    
    @media (max-width: 900px) {
      .side { width: 100%; }
    }
    
    .grid{
      display:grid; 
      grid-template-columns:1fr; 
      gap:10px;
      flex: 1;
    }
    
    .row2{
      display:grid; 
      grid-template-columns:1fr 1fr; 
      gap:10px;
    }
    
    @media (max-width:600px){ 
      .row2{ grid-template-columns:1fr; } 
    }
    
    label{
      display:block; 
      margin-bottom:6px; 
      font-weight:700; 
      font-size:13px;
    }
    
    .btns{
      display:flex; 
      gap:10px; 
      flex-wrap:wrap; 
      justify-content:center; 
      margin-top:6px;
    }
    
    button{
      padding:10px 14px; 
      font-size:14px; 
      font-weight:800;
      border:none; 
      border-radius:6px; 
      cursor:pointer;
      color:#fff; 
      transition:all .2s;
      box-shadow:0 4px 6px rgba(0,0,0,.2);
      background:linear-gradient(to bottom,#3498db,#2980b9);
      flex: 1;
      min-width: 100px;
    }
    
    button:hover{
      filter:brightness(1.07); 
      transform:translateY(-1px); 
      box-shadow:0 6px 10px rgba(0,0,0,.28);
    }
    
    button:active{ transform:translateY(1px); }
    
    #resetBtn{ background:linear-gradient(to bottom,#e74c3c,#c0392b); }
    #stopBtn{ background:linear-gradient(to bottom,#95a5a6,#7f8c8d); }
    
    .small{
      font-size:12px; 
      opacity:.9;
      text-align: center;
    }
    
    .prediction-controls{
      display:flex; 
      align-items:center; 
      gap:8px; 
      justify-content:center;
    }
    
    .chip{
      background:rgba(255,255,255,.09); 
      padding:8px 10px; 
      border-radius:10px;
    }
    
    .info-panel{
      background:var(--panel-bg); 
      padding:12px; 
      border-radius:8px;
      text-align:center; 
      font-size:13px;
    }
    
    .physics-info,.stats{
      display:flex; 
      gap:10px; 
      justify-content:space-around; 
      flex-wrap:wrap; 
      margin-top:8px;
    }
    
    .info-item{
      background:rgba(255,255,255,.1); 
      padding:7px 12px; 
      border-radius:999px;
    }
    
    .stat-item{
      background:rgba(0,0,0,.5); 
      padding:7px 12px; 
      border-radius:6px;
    }
    
    .progress-wrap{
      display:none; 
      gap:8px; 
      align-items:center;
    }
    
    .progress-wrap.show{ display:flex; }
    
    progress{
      width:100%; 
      height:14px;
    }
    
    .disabled{ opacity:.55; pointer-events:none; }
    
    .smart-aim-status {
      text-align: center;
      padding: 8px;
      background: rgba(46, 204, 113, 0.2);
      border-radius: 6px;
      display: none;
    }
    
    .smart-aim-status.show { display: block; }
  </style>
</head>
<body>
  <h1>å°çƒå¥½è¿æ¨¡æ‹Ÿå™¨</h1>

  <div class="container">
    <div class="content-wrapper">
      <div class="table-section">
        <div class="canvas-container">
          <canvas id="poolTable" width="800" height="400"></canvas>
        </div>
        
        <div class="controls-below">
          <div class="control-group">
            <div class="control-label">
              <span>é¢„æµ‹æ—¶é—´:</span>
              <span id="predictionTimeValue" class="control-value">30</span>s
            </div>
            <input type="range" id="predictionTimeControl" min="5" max="50" value="30" step="5" />
          </div>
          
          <div class="control-group">
            <div class="control-label">
              <span>è§’åº¦å¾®è°ƒ (Â±1Â°):</span>
              <span id="angleFineTuneValue" class="control-value">0.000</span>Â°
            </div>
            <input type="range" id="angleFineTune" min="-1" max="1" value="0" step="0.001" />
          </div>
        </div>
      </div>

      <div class="side" id="sidePanel">
        <div class="grid">
          <div class="row2">
            <div class="chip">
              <label>çº¢çƒå…¥è¢‹æ•°: <span id="pottedCount">0</span></label>
              <div class="small">æ¨¡æ‹Ÿæ—¶é—´: <span id="timeCounter">0.00</span>s</div>
            </div>
            <div class="chip">
              <label>
                <input type="checkbox" id="showTrajectoryDuringSimulation" style="width:auto;margin-right:8px;" checked />
                è¿è¡Œæ—¶æ˜¾ç¤ºè½¨è¿¹
              </label>
            </div>
          </div>

          <div class="chip">
            <label for="speedControl">ç™½çƒåˆå§‹é€Ÿåº¦: <span id="speedValue">7.00</span> å•ä½/ç§’</label>
            <input type="range" id="speedControl" min="0.1" max="30" value="7" step="0.01" />
          </div>

          <div class="btns">
            <button id="stopBtn">åœæ­¢æ‰€æœ‰çƒ</button>
            <button id="resetBtn">é‡æ–°å¼€å§‹</button>
          </div>

          <div class="progress-wrap" id="smartProgressWrap">
            <progress id="smartProgress" value="0" max="2001"></progress>
            <div class="small" style="min-width:96px;text-align:right;"><span id="smartProgressText">0%</span></div>
          </div>
          
          <div class="smart-aim-status" id="smartAimStatus">
            æ­£åœ¨å¸®ä½ ç§¯æ”’ç‹—è¿
          </div>

          <div class="row2">
            <div class="chip">
              <label for="massControl">ç™½çƒè´¨é‡: <span id="massValue">1.0</span></label>
              <input type="range" id="massControl" min="-1" max="0.5" value="0" step="0.01" />
            </div>
            <div class="chip">
              <label for="frictionControl">æ¡Œé¢æ‘©æ“¦åŠ›: <span id="frictionValue">0.10</span></label>
              <input type="range" id="frictionControl" min="0" max="1" value="0.1" step="0.01" />
            </div>
          </div>

          <div class="row2">
            <div class="chip">
              <label for="collisionLossControl">ç¢°æ’èƒ½é‡æŸå¤±: <span id="collisionLossValue">5</span>%</label>
              <input type="range" id="collisionLossControl" min="0" max="20" value="5" step="0.1" />
            </div>
            <div class="chip">
              <label for="boundaryLossControl">è¾¹ç•Œèƒ½é‡æŸå¤±: <span id="boundaryLossValue">5</span>%</label>
              <input type="range" id="boundaryLossControl" min="0" max="20" value="5" step="0.1" />
            </div>
          </div>

          <div class="chip">
            <label>é¢„æµ‹ç¢°æ’æ¬¡æ•°: <span id="maxCollisionsValue">2</span></label>
            <div class="prediction-controls">
              <button id="decreaseCollisionsBtn">-</button>
              <span id="maxCollisionsDisplay">2</span>
              <button id="increaseCollisionsBtn">+</button>
            </div>
          </div>
          
          <div class="chip">
            <label>è¢‹å£å¤§å°: <span id="pocketSizeValue">0.60</span></label>
            <div class="prediction-controls">
              <button id="decreasePocketSizeBtn">-</button>
              <span id="pocketSizeDisplay">0.60</span>
              <button id="increasePocketSizeBtn">+</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="info-panel">
      <div class="stats">
        <div class="stat-item">è¯´æ˜ï¼šçè’™ä¸€æ†å°±è¡Œã€‚</div>
      </div>
    </div>
  </div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  const canvas = $('poolTable');
  const ctx = canvas.getContext('2d');
  const sidePanel = $('sidePanel');

  const SCALE = 40, TABLE_W = 20, TABLE_H = 10;
  const BALL_R = 0.25;
  const RED_MASS = 1;

  const FPS = 60, DT = 1 / FPS;
  const STOP_V = 0.01, EPS = 1e-9;

  const COLORS = ['#E74C3C','#3498DB','#2ECC71','#F1C40F','#9B59B6','#1ABC9C','#E67E22','#34495E','#FF6B6B','#4ECDC4'];

  let whiteBallSpeed = 7;
  let whiteBallMass = 1;
  let collisionLoss = 5;
  let friction = 0.1;
  let boundaryLoss = 5;
  let predictionTime = 30;
  let maxCollisions = 2;
  let pocketSize = 0.6;

  let balls = [], pockets = [];
  let running = false, animId = null;
  let showTrajInRun = true;

  let pottedCount = 0, simTime = 0;

  // aiming
  let aimX = 0, aimY = 0, aimLocked = false;
  let angleFineTune = 0;

  // running trajectory cache: update only for impacted balls on collision/boundary
  const runTraj = { enabled:false, byIndex:new Map() };

  // redraw scheduler
  let redrawPending = false;
  const requestRedraw = () => {
    if (redrawPending) return;
    redrawPending = true;
    requestAnimationFrame(() => { redrawPending = false; redrawAll(); });
  };

  class Ball {
    constructor(x,y,r,m,color,isWhite=false){
      this.x=x; this.y=y; this.r=r; this.m=m; this.color=color; this.isWhite=isWhite;
      this.vx=0; this.vy=0; this.potted=false;
    }
    speed(){ return Math.hypot(this.vx,this.vy); }
    stopped(){ return this.speed() < STOP_V; }
    draw(){
      if (this.potted) return;
      ctx.beginPath();
      ctx.arc(this.x*SCALE,this.y*SCALE,this.r*SCALE,0,Math.PI*2);
      ctx.fillStyle=this.color; ctx.fill();
      ctx.strokeStyle='#000'; ctx.lineWidth=1; ctx.stroke();
      if (!this.isWhite){
        ctx.beginPath();
        ctx.arc(this.x*SCALE-this.r*SCALE*0.3,this.y*SCALE-this.r*SCALE*0.3,this.r*SCALE*0.2,0,Math.PI*2);
        ctx.fillStyle='rgba(255,255,255,.9)'; ctx.fill();
      }
    }
  }

  class Pocket {
    constructor(x,y){ 
      this.x=x; 
      this.y=y; 
      this.r = pocketSize * 0.5; 
      this.r2=this.r*this.r; 
    }
    updateSize() {
      this.r = pocketSize * 0.5;
      this.r2 = this.r * this.r;
    }
    draw(){
      ctx.beginPath();
      ctx.arc(this.x*SCALE,this.y*SCALE,this.r*SCALE,0,Math.PI*2);
      ctx.fillStyle='#000'; ctx.fill();
      ctx.beginPath();
      ctx.arc(this.x*SCALE,this.y*SCALE,this.r*SCALE*0.7,0,Math.PI*2);
      ctx.fillStyle='#333'; ctx.fill();
      ctx.beginPath();
      ctx.arc(this.x*SCALE-this.r*SCALE*0.3,this.y*SCALE-this.r*SCALE*0.3,this.r*SCALE*0.2,0,Math.PI*2);
      ctx.fillStyle='rgba(100,100,100,.5)'; ctx.fill();
    }
    check(ball){
      const dx = ball.x - this.x, dy = ball.y - this.y;
      const d2 = dx*dx + dy*dy;
      const rr = (this.r + ball.r);
      return d2 < rr*rr;
    }
  }

  const linearToLog = (v) => v >= 0 ? 1 + v*9 : Math.pow(10, v);

  const setAngleFineTune = (v) => {
    angleFineTune = v;
    $('angleFineTune').value = v;
    $('angleFineTuneValue').textContent = v.toFixed(3);
  };

  // è¿›å…¥"è°ƒæ•´å‡»çƒçº¿/æ¨¡æ‹Ÿè½¨è¿¹"çŠ¶æ€ï¼šè§£é” + å¾®è°ƒå½’é›¶
  const enterAimAdjustState = () => { 
    aimLocked = false; 
    setAngleFineTune(0); 
  };

  const updateUI = () => {
    $('speedValue').textContent = whiteBallSpeed.toFixed(2);
    $('massValue').textContent = whiteBallMass.toFixed(1);
    $('collisionLossValue').textContent = collisionLoss;
    $('frictionValue').textContent = friction.toFixed(2);
    $('boundaryLossValue').textContent = boundaryLoss;
    $('predictionTimeValue').textContent = predictionTime;
    $('maxCollisionsValue').textContent = maxCollisions;
    $('maxCollisionsDisplay').textContent = maxCollisions;
    $('pocketSizeValue').textContent = pocketSize.toFixed(2);
    $('pocketSizeDisplay').textContent = pocketSize.toFixed(2);
    $('pottedCount').textContent = pottedCount;
    $('timeCounter').textContent = simTime.toFixed(2);
    $('showTrajectoryDuringSimulation').checked = showTrajInRun;
  };

  const initGame = () => {
    balls = []; pockets = [];
    pottedCount = 0; simTime = 0;
    running = false; if (animId) cancelAnimationFrame(animId); animId = null;
    runTraj.byIndex.clear(); runTraj.enabled = false;

    pockets.push(new Pocket(0,0), new Pocket(TABLE_W,0), new Pocket(0,TABLE_H), new Pocket(TABLE_W,TABLE_H));
    pockets.push(new Pocket(TABLE_W/2,0), new Pocket(TABLE_W/2,TABLE_H));
    pockets.forEach(p => p.updateSize());

    const white = new Ball(2, TABLE_H/2, BALL_R, whiteBallMass, '#fff', true);
    balls.push(white);

    const startX=15, startY=TABLE_H/2;
    let colorIdx=0;
    for (let row=0; row<4; row++) for (let col=0; col<=row; col++){
      if (balls.length > 10) break;
      const hs=BALL_R*2.2, vs=BALL_R*2.0;
      const x = startX + row*hs + (Math.random()-0.5)*0.1;
      const y = startY + (col-row/2)*vs + (Math.random()-0.5)*0.1;
      balls.push(new Ball(x,y,BALL_R,RED_MASS,COLORS[colorIdx++%COLORS.length]));
    }

    aimX = white.x + 5; aimY = white.y;
    enterAimAdjustState();
    updateUI();
    redrawAll();
  };

  // ---------- physics ----------
  const applyFriction = (vx,vy,dt) => {
    const s = Math.hypot(vx,vy);
    if (s < EPS) return [0,0];
    const ns = Math.max(0, s - friction*dt);
    const k = ns / s;
    return [vx*k, vy*k];
  };

  const stepBall = (b,dt) => {
    if (b.potted) return false;

    [b.vx,b.vy] = applyFriction(b.vx,b.vy,dt);

    b.x += b.vx*dt; b.y += b.vy*dt;

    const blf = (100 - boundaryLoss)/100;
    let hit=false;

    if (b.x - b.r < 0){ b.x=b.r; b.vx=-b.vx*blf; hit=true; }
    else if (b.x + b.r > TABLE_W){ b.x=TABLE_W-b.r; b.vx=-b.vx*blf; hit=true; }

    if (b.y - b.r < 0){ b.y=b.r; b.vy=-b.vy*blf; hit=true; }
    else if (b.y + b.r > TABLE_H){ b.y=TABLE_H-b.r; b.vy=-b.vy*blf; hit=true; }

    return hit;
  };

  // collision using normal/tangent (no trig)
  const resolveBallCollision = (b1,b2) => {
    if (b1.potted || b2.potted) return false;
    const dx=b2.x-b1.x, dy=b2.y-b1.y;
    const minD=b1.r+b2.r;
    const d2=dx*dx+dy*dy;
    if (d2 >= minD*minD || d2 < EPS) return false;

    const d = Math.sqrt(d2);
    const nx = dx/d, ny = dy/d;
    const tx = -ny, ty = nx;

    const v1n = b1.vx*nx + b1.vy*ny;
    const v1t = b1.vx*tx + b1.vy*ty;
    const v2n = b2.vx*nx + b2.vy*ny;
    const v2t = b2.vx*tx + b2.vy*ty;

    const m1=b1.m, m2=b2.m;
    const v1n2 = (v1n*(m1-m2) + 2*m2*v2n) / (m1+m2);
    const v2n2 = (v2n*(m2-m1) + 2*m1*v1n) / (m1+m2);

    const elf = (100 - collisionLoss)/100;

    b1.vx = (v1n2*nx + v1t*tx) * elf;
    b1.vy = (v1n2*ny + v1t*ty) * elf;
    b2.vx = (v2n2*nx + v2t*tx) * elf;
    b2.vy = (v2n2*ny + v2t*ty) * elf;

    const overlap = (minD - d)/2;
    b1.x -= overlap*nx; b1.y -= overlap*ny;
    b2.x += overlap*nx; b2.y += overlap*ny;

    return true;
  };

  const checkPockets = (arr, countUI) => {
    for (const b of arr){
      if (b.potted || b.isWhite) continue;
      for (const p of pockets){
        if (p.check(b)){
          b.potted = true;
          if (countUI){ pottedCount++; $('pottedCount').textContent = pottedCount; }
          break;
        }
      }
    }
  };

  // ---------- aiming helpers ----------
  const getShotAngle = (white, fineDeg=angleFineTune) => {
    const dx = aimX - white.x, dy = aimY - white.y;
    if (Math.hypot(dx,dy) < EPS) return null;
    return Math.atan2(dy,dx) + fineDeg * Math.PI/180;
  };

  // ---------- prediction (static) ----------
  const cloneBalls = (src) => src.map(b => {
    const nb = new Ball(b.x,b.y,b.r,b.m,b.color,b.isWhite);
    nb.vx=b.vx; nb.vy=b.vy; nb.potted=b.potted;
    return nb;
  });

  function simulatePrediction({ baseBalls, includeAimIfStationary, recordSet=null }) {
    const ps = cloneBalls(baseBalls);
    if (includeAimIfStationary) {
      const w = ps.find(b => b.isWhite);
      if (w && !w.potted && Math.hypot(w.vx,w.vy) < 0.001) {
        const ang = getShotAngle(w);
        if (ang !== null) { w.vx = whiteBallSpeed*Math.cos(ang); w.vy = whiteBallSpeed*Math.sin(ang); }
      }
    }
    const steps = Math.max(1, Math.floor(predictionTime/DT));
    const cc = new Array(ps.length).fill(0);
    const traj = ps.map(b => ({points:[], color:b.color}));
    const want = (i) => !recordSet || recordSet.has(i);

    for (let step=0; step<steps; step++){
      for (let i=0; i<ps.length; i++){
        if (!want(i)) continue;
        const b=ps[i];
        if (!b.potted && cc[i] <= maxCollisions) traj[i].points.push({x:b.x,y:b.y});
      }
      for (let i=0; i<ps.length; i++){
        if (ps[i].potted || cc[i] > maxCollisions) continue;
        const hit = stepBall(ps[i], DT);
        if (hit) cc[i]++; // è¾¹ç•Œè®¡ä¸ºä¸€æ¬¡"ç¢°æ’æ¬¡æ•°"
      }
      for (let i=0; i<ps.length; i++){
        if (ps[i].potted || cc[i] > maxCollisions) continue;
        for (let j=i+1; j<ps.length; j++){
          if (ps[j].potted || cc[j] > maxCollisions) continue;
          if (resolveBallCollision(ps[i], ps[j])) { cc[i]++; cc[j]++; }
        }
      }
      checkPockets(ps, false);
    }
    return traj;
  }

  // ---------- draw ----------
  const drawTable = () => {
    ctx.fillStyle='#27ae60';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.strokeStyle='#8b4513'; ctx.lineWidth=6;
    ctx.strokeRect(0,0,canvas.width,canvas.height);

    ctx.strokeStyle='#1a5c30'; ctx.lineWidth=2;
    ctx.strokeRect(BALL_R*SCALE,BALL_R*SCALE,(TABLE_W-2*BALL_R)*SCALE,(TABLE_H-2*BALL_R)*SCALE);

    pockets.forEach(p => p.draw());
    balls.forEach(b => b.draw());
  };

  const strokeTrajectory = (pts, color, dynamicAlpha=true) => {
    if (!pts || pts.length < 2) return;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(pts[0].x*SCALE, pts[0].y*SCALE);
    for (let i=1;i<pts.length;i++){
      const a = dynamicAlpha ? Math.max(0.1, 1 - (i/pts.length)*0.9) : 0.65;
      let rgba;
      if (color[0]==='#'){
        const r=parseInt(color.slice(1,3),16), g=parseInt(color.slice(3,5),16), b=parseInt(color.slice(5,7),16);
        rgba=`rgba(${r},${g},${b},${a})`;
      } else rgba=`rgba(255,255,255,${a})`;
      ctx.strokeStyle = rgba;
      ctx.lineTo(pts[i].x*SCALE, pts[i].y*SCALE);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(pts[i].x*SCALE, pts[i].y*SCALE);
    }
  };

  const drawPrediction = () => {
    if (running) {
      if (!showTrajInRun || !runTraj.enabled) return;
      for (const [i,t] of runTraj.byIndex.entries()){
        if (balls[i] && !balls[i].potted) strokeTrajectory(t.points, t.color, false);
      }
      return;
    }
    // é™æ­¢/å‡†å¤‡å‡»çƒï¼šæ°¸è¿œå®æ—¶é¢„æµ‹ï¼ˆä¿®å¤"ä¸‹ä¸€æ†ä¸æ˜¾ç¤ºè½¨è¿¹"çš„æ ¹å› ï¼šä¸ä¾èµ–ä»»ä½•ç¼“å­˜/å¼€å…³ï¼‰
    const traj = simulatePrediction({ baseBalls: balls, includeAimIfStationary: true, recordSet: null });
    for (let i=0;i<traj.length;i++){
      if (balls[i] && balls[i].potted) continue;
      strokeTrajectory(traj[i].points, traj[i].color, true);
    }
  };

  const drawAimLine = () => {
    if (running) return;
    const w = balls.find(b => b.isWhite);
    if (!w || w.potted) return;
    const ang = getShotAngle(w);
    if (ang === null) return;
    const ux=Math.cos(ang), uy=Math.sin(ang);

    ctx.beginPath();
    ctx.moveTo(w.x*SCALE, w.y*SCALE);
    ctx.lineTo((w.x + ux*5)*SCALE, (w.y + uy*5)*SCALE);
    ctx.strokeStyle='rgba(255,255,255,.7)'; ctx.lineWidth=2; ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(w.x*SCALE, w.y*SCALE);
    ctx.lineTo((w.x - ux*3)*SCALE, (w.y - uy*3)*SCALE);
    ctx.strokeStyle='rgba(255,0,0,.8)'; ctx.lineWidth=3; ctx.stroke();
  };

  const redrawAll = () => {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawTable();
    drawPrediction();
    drawAimLine();
  };

  // ---------- running trajectory helpers ----------
  const setRunTrajForIndices = (indices) => {
    if (!showTrajInRun || !runTraj.enabled || !indices.length) return;
    const rec = new Set(indices);
    const traj = simulatePrediction({ baseBalls: balls, includeAimIfStationary: false, recordSet: rec });
    for (const i of indices) runTraj.byIndex.set(i, traj[i]);
  };
  const enableRunTraj = () => {
    runTraj.enabled = true;
    runTraj.byIndex.clear();
    const moving = [];
    for (let i=0;i<balls.length;i++) if (!balls[i].potted && balls[i].speed() > STOP_V) moving.push(i);
    if (moving.length) setRunTrajForIndices(moving);
  };
  const disableRunTraj = () => { runTraj.enabled = false; runTraj.byIndex.clear(); };

  // ---------- simulation loop (no pause) ----------
  const tick = () => {
    if (!running) return;

    const dirty = new Set();

    for (let i=0;i<balls.length;i++){
      if (balls[i].potted) continue;
      const hitWall = stepBall(balls[i], DT);
      if (hitWall) dirty.add(i);
    }

    for (let i=0;i<balls.length;i++){
      for (let j=i+1;j<balls.length;j++){
        if (resolveBallCollision(balls[i], balls[j])) { dirty.add(i); dirty.add(j); }
      }
    }

    checkPockets(balls, true);

    if (showTrajInRun && runTraj.enabled && dirty.size) setRunTrajForIndices([...dirty]);

    simTime += DT;
    $('timeCounter').textContent = simTime.toFixed(2);

    const allStopped = balls.every(b => b.potted || b.stopped());
    if (allStopped){
      running = false;
      animId = null;
      // çƒåœåï¼šè¿›å…¥ä¸‹ä¸€æ†"è°ƒæ•´/é¢„æµ‹"çŠ¶æ€ï¼Œå¹¶å¼ºåˆ¶é‡ç»˜ï¼Œä¿è¯è½¨è¿¹ç«‹åˆ»å‡ºç°ï¼ˆä¿®å¤2ï¼‰
      disableRunTraj();
      enterAimAdjustState();
      
      // æ–°å¢ï¼šå‡»çƒåœæ­¢åæ‰§è¡Œä¸€æ¬¡åœæ­¢æ‰€æœ‰çƒçš„æ“ä½œï¼Œç¡®ä¿æ­£ç¡®åˆå§‹åŒ–
      stopAllBalls();
      
      // æ–°å¢ï¼šæ£€æŸ¥æ˜¯å¦æ‰€æœ‰çƒéƒ½å·²è½è¢‹ï¼Œå¦‚æœæ˜¯åˆ™è‡ªåŠ¨é‡æ–°å¼€å§‹
      const redBalls = balls.filter(b => !b.isWhite);
      if (redBalls.every(b => b.potted)) {
        setTimeout(initGame, 1000);
      }
      
      return;
    }

    redrawAll();
    animId = requestAnimationFrame(tick);
  };

  const shoot = () => {
    if (running) return; // æ— æš‚åœï¼šè¿è¡Œä¸­ä¸å“åº”å‡»çƒ
    const w = balls.find(b => b.isWhite);
    if (!w || w.potted) return;
    const ang = getShotAngle(w);
    if (ang === null) return;

    w.vx = whiteBallSpeed*Math.cos(ang);
    w.vy = whiteBallSpeed*Math.sin(ang);

    running = true;

    // è¿è¡Œæ—¶è½¨è¿¹ï¼šå¯ç”¨ååªåœ¨ç¢°æ’/åå¼¹æ—¶æ›´æ–°å—å½±å“çƒ
    if (showTrajInRun) enableRunTraj(); else disableRunTraj();

    animId = requestAnimationFrame(tick);
  };

  const stopAllBalls = () => {
    balls.forEach(b => { b.vx=0; b.vy=0; });
    if (running){
      running = false;
      if (animId) cancelAnimationFrame(animId);
      animId = null;
    }
    disableRunTraj();
    enterAimAdjustState();
    requestRedraw();
  };

  // ---------- pointer aiming ----------
  const clientToTable = (clientX, clientY) => {
    const r = canvas.getBoundingClientRect();
    return { x:(clientX - r.left)/SCALE, y:(clientY - r.top)/SCALE };
  };

  document.addEventListener('pointermove', (e) => {
    // æ™ºèƒ½ç„å‡†æœŸé—´ç¦æ­¢æ›´æ”¹æ–¹å‘
    if (running || aimLocked || smart.running) return;
    
    // ä»…åœ¨ç”»å¸ƒå†…éƒ¨å“åº”
    const rect = canvas.getBoundingClientRect();
    if (e.clientX < rect.left || e.clientX > rect.right || 
        e.clientY < rect.top || e.clientY > rect.bottom) return;
        
    const {x,y} = clientToTable(e.clientX, e.clientY);
    aimX=x; aimY=y;
    requestRedraw();
  }, {passive:true});

  document.addEventListener('pointerdown', (e) => {
    if (running || smart.running) return;
    
    // ä»…åœ¨ç”»å¸ƒå†…éƒ¨å“åº”
    const rect = canvas.getBoundingClientRect();
    if (e.clientX < rect.left || e.clientX > rect.right || 
        e.clientY < rect.top || e.clientY > rect.bottom) return;
        
    const {x,y} = clientToTable(e.clientX, e.clientY);
    aimX=x; aimY=y;

    // ç‚¹å‡»é”å®šæ–¹å‘å¹¶è‡ªåŠ¨æ‰§è¡Œæ™ºèƒ½ç„å‡†
    aimLocked = true;
    smartAim();
    
    requestRedraw();
  });

  // ---------- Smart Aim ----------
  const smart = {
    running:false,
    cancel:false
  };

  const setSmartUI = (on) => {
    smart.running = on;
    $('smartProgressWrap').classList.toggle('show', on);
    $('smartAimStatus').classList.toggle('show', on);
    $('stopBtn').classList.toggle('disabled', on);
    $('resetBtn').classList.toggle('disabled', on);
  };

  // é«˜æ€§èƒ½è¯„ä¼°ï¼šç”¨æ•°ç»„æ¨¡æ‹Ÿï¼ˆé¿å…æ¯ä¸ªè§’åº¦å¤§é‡å¯¹è±¡åˆ†é…ï¼‰
  function buildBaseState() {
    const n = balls.length;
    const bx = new Float64Array(n), by = new Float64Array(n);
    const bvx = new Float64Array(n), bvy = new Float64Array(n);
    const br = new Float64Array(n), bm = new Float64Array(n);
    const potted = new Uint8Array(n);
    let wi = -1;
    for (let i=0;i<n;i++){
      const b=balls[i];
      bx[i]=b.x; by[i]=b.y; bvx[i]=b.vx; bvy[i]=b.vy;
      br[i]=b.r; bm[i]=b.m; potted[i]=b.potted?1:0;
      if (b.isWhite) wi=i;
    }
    const pairI=[], pairJ=[];
    for (let i=0;i<n;i++) for (let j=i+1;j<n;j++){ pairI.push(i); pairJ.push(j); }
    return { n, wi, bx,by,bvx,bvy,br,bm,potted, pairI, pairJ };
  }

  function evalAngle(base, fineDeg) {
    const {n,wi,pairI,pairJ} = base;

    const x = new Float64Array(n), y = new Float64Array(n);
    const vx = new Float64Array(n), vy = new Float64Array(n);
    const p = new Uint8Array(n);

    x.set(base.bx); y.set(base.by); vx.set(base.bvx); vy.set(base.bvy); p.set(base.potted);

    // ä»…åœ¨ç™½çƒé™æ­¢æ—¶æŒ‰"ç„å‡†æ–¹å‘ + fineDeg"èµ‹åˆé€Ÿåº¦
    if (wi !== -1 && !p[wi] && Math.hypot(vx[wi],vy[wi]) < 0.001) {
      const dx = aimX - x[wi], dy = aimY - y[wi];
      const d = Math.hypot(dx,dy);
      if (d > EPS) {
        const ang = Math.atan2(dy,dx) + fineDeg*Math.PI/180;
        vx[wi] = whiteBallSpeed*Math.cos(ang);
        vy[wi] = whiteBallSpeed*Math.sin(ang);
      }
    }

    const steps = Math.max(1, Math.floor(predictionTime/DT));
    const blf = (100 - boundaryLoss)/100;
    const elf = (100 - collisionLoss)/100;

    let pottedNew = 0;
    let lastPotTime = 0;

    // å·²ç»å…¥è¢‹çš„ä¸è®¡å…¥"è¿™ä¸€æ†"
    const initialPotted = new Uint8Array(n);
    initialPotted.set(p);

    for (let step=0; step<steps; step++){
      // æ—©åœï¼šæ‰€æœ‰éå…¥è¢‹çƒéƒ½å¾ˆæ…¢
      let anyMove=false;
      for (let i=0;i<n;i++){
        if (p[i]) continue;
        if (Math.hypot(vx[i],vy[i]) >= STOP_V){ anyMove=true; break; }
      }
      if (!anyMove) break;

      // friction + move + boundary
      for (let i=0;i<n;i++){
        if (p[i]) continue;

        const s = Math.hypot(vx[i],vy[i]);
        if (s > EPS) {
          const ns = Math.max(0, s - friction*DT);
          const k = ns / s;
          vx[i] *= k; vy[i] *= k;
        }

        x[i] += vx[i]*DT; y[i] += vy[i]*DT;

        if (x[i] - base.br[i] < 0){ x[i]=base.br[i]; vx[i] = -vx[i]*blf; }
        else if (x[i] + base.br[i] > TABLE_W){ x[i]=TABLE_W-base.br[i]; vx[i] = -vx[i]*blf; }

        if (y[i] - base.br[i] < 0){ y[i]=base.br[i]; vy[i] = -vy[i]*blf; }
        else if (y[i] + base.br[i] > TABLE_H){ y[i]=TABLE_H-base.br[i]; vy[i] = -vy[i]*blf; }
      }

      // ball-ball
      for (let k=0;k<pairI.length;k++){
        const i=pairI[k], j=pairJ[k];
        if (p[i] || p[j]) continue;

        const dx = x[j]-x[i], dy = y[j]-y[i];
        const minD = base.br[i] + base.br[j];
        const d2 = dx*dx + dy*dy;
        if (d2 >= minD*minD || d2 < EPS) continue;

        const d = Math.sqrt(d2);
        const nx = dx/d, ny = dy/d;
        const tx = -ny, ty = nx;

        const v1n = vx[i]*nx + vy[i]*ny;
        const v1t = vx[i]*tx + vy[i]*ty;
        const v2n = vx[j]*nx + vy[j]*ny;
        const v2t = vx[j]*tx + vy[j]*ty;

        const m1 = base.bm[i], m2 = base.bm[j];
        const v1n2 = (v1n*(m1-m2) + 2*m2*v2n)/(m1+m2);
        const v2n2 = (v2n*(m2-m1) + 2*m1*v1n)/(m1+m2);

        vx[i] = (v1n2*nx + v1t*tx) * elf;
        vy[i] = (v1n2*ny + v1t*ty) * elf;
        vx[j] = (v2n2*nx + v2t*tx) * elf;
        vy[j] = (v2n2*ny + v2t*ty) * elf;

        const overlap = (minD - d)/2;
        x[i] -= overlap*nx; y[i] -= overlap*ny;
        x[j] += overlap*nx; y[j] += overlap*ny;
      }

      // pockets (åªç»Ÿè®¡éç™½çƒã€ä¸”æœ¬æ¬¡æ–°å…¥è¢‹)
      const t = (step+1)*DT;
      for (let i=0;i<n;i++){
        if (p[i]) continue;
        if (i === base.wi) continue;
        // æ£€è¢‹
        for (let pi=0; pi<pockets.length; pi++){
          const pk = pockets[pi];
          const dx = x[i]-pk.x, dy = y[i]-pk.y;
          const rr = (pk.r + base.br[i]);
          if (dx*dx + dy*dy < rr*rr){
            p[i] = 1;
            if (!initialPotted[i]) {
              pottedNew++;
              if (t > lastPotTime) lastPotTime = t;
            }
            break;
          }
        }
      }
    }

    return { pottedNew, lastPotTime };
  }

  async function smartAim() {
    if (running || smart.running) return;

    const w = balls.find(b => b.isWhite);
    if (!w || w.potted) return;
    if (getShotAngle(w, 0) === null) return; // æ— ç„å‡†æ–¹å‘

    // ğŸ‘‡ æ–°å¢ï¼šç«‹å³é”å®šå½“å‰æ–¹å‘
    aimLocked = true;
    setAngleFineTune(0); // å¾®è°ƒæ¸…é›¶ä»¥æ–¹ä¾¿åç»­èµ‹å€¼æœ€ä¼˜å€¼

    smart.cancel = false;
    setSmartUI(true);

    // ğŸ‘‡ ç¦ç”¨ç›¸å…³æ§ä»¶ä»¥é˜²å¹²æ‰°
    const inputsToDisable = [
      'angleFineTune',
      'speedControl',
      'massControl',
      'frictionControl',
      'collisionLossControl',
      'boundaryLossControl'
    ];
    inputsToDisable.forEach(id => $(id).disabled = true);

    const total = 2001;
    $('smartProgress').max = total;
    $('smartProgress').value = 0;
    $('smartProgressText').textContent = '0%';

    // è¿›å…¥æšä¸¾ï¼šç›¸å½“äºè¿›å…¥"è°ƒæ•´"æ€ -> å¾®è°ƒå…ˆå½’é›¶ï¼ˆå¹¶ä¸”æœ€ç»ˆä¼šé€‰æœ€ä½³è§’åº¦ï¼‰
    enterAimAdjustState();

    const base = buildBaseState();

    let bestDeg = 0;
    let bestPot = -1;
    let bestTime = Infinity;

    // åˆ†å¸§æšä¸¾ï¼Œé¿å…å¡æ­»ï¼›æ‰¹é‡å¤§å°è‡ªé€‚åº”
    let idx = 0;
    const startDeg = -1, stepDeg = 0.001;

    while (idx < total && !smart.cancel) {
      const t0 = performance.now();
      let batch = 0;

      while (idx < total && batch < 80) { // å…ˆç»™ä¸ªä¸Šé™
        const fineDeg = startDeg + idx*stepDeg;
        const r = evalAngle(base, fineDeg);

        // ç›®æ ‡ï¼šè¿›çƒæ•°æœ€å¤šï¼›è‹¥ç›¸åŒåˆ™æœ€åè¿›çƒæ—¶é—´å°½é‡å°
        if (r.pottedNew > bestPot || (r.pottedNew === bestPot && r.lastPotTime < bestTime)) {
          bestPot = r.pottedNew;
          bestTime = r.lastPotTime;
          bestDeg = fineDeg;
        }

        idx++; batch++;

        // è½¯æ—¶é—´ç‰‡ï¼šæ¯å¸§æ§åˆ¶åœ¨ ~8-10msï¼Œå…¼é¡¾é€Ÿåº¦ä¸UIå“åº”
        if (performance.now() - t0 > 10) break;
      }

      $('smartProgress').value = idx;
      $('smartProgressText').textContent = Math.floor(idx/total*100) + '%';

      await new Promise(requestAnimationFrame);
    }

    setSmartUI(false);

    // ğŸ‘‡ æ¢å¤æ§ä»¶å¯ç”¨æ€§
    inputsToDisable.forEach(id => $(id).disabled = false);

    if (!smart.cancel) {
      setAngleFineTune(bestDeg);
      aimLocked = true; // è‡ªåŠ¨é”å®šæ–¹å‘
      
      // è‡ªåŠ¨æ‰§è¡Œå‡»çƒ
      setTimeout(() => {
        shoot();
      }, 300);
      
      requestRedraw();
      console.log('[æ™ºèƒ½ç„å‡†] bestDeg=', bestDeg.toFixed(3), 'potted=', bestPot, 'lastPotTime=', bestTime.toFixed(3));
    }
  }

  // ---------- controls ----------
  $('stopBtn').addEventListener('click', stopAllBalls);
  $('resetBtn').addEventListener('click', initGame);

  $('speedControl').addEventListener('input', (e) => { whiteBallSpeed = parseFloat(e.target.value); updateUI(); requestRedraw(); });

  $('massControl').addEventListener('input', (e) => {
    whiteBallMass = linearToLog(parseFloat(e.target.value));
    const w = balls.find(b => b.isWhite);
    if (w) w.m = whiteBallMass;
    updateUI(); requestRedraw();
  });

  $('collisionLossControl').addEventListener('input', (e) => { collisionLoss = parseInt(e.target.value,10); updateUI(); requestRedraw(); });
  $('frictionControl').addEventListener('input', (e) => { friction = parseFloat(e.target.value); updateUI(); requestRedraw(); });
  $('boundaryLossControl').addEventListener('input', (e) => { boundaryLoss = parseInt(e.target.value,10); updateUI(); requestRedraw(); });
  $('predictionTimeControl').addEventListener('input', (e) => { predictionTime = parseInt(e.target.value,10); updateUI(); requestRedraw(); });

  $('increaseCollisionsBtn').addEventListener('click', () => { if (maxCollisions < 10) { maxCollisions++; updateUI(); requestRedraw(); }});
  $('decreaseCollisionsBtn').addEventListener('click', () => { if (maxCollisions > 0) { maxCollisions--; updateUI(); requestRedraw(); }});

  $('increasePocketSizeBtn').addEventListener('click', () => { 
    if (pocketSize < 1.0) { 
      pocketSize = Math.min(1.0, pocketSize + 0.05); 
      pockets.forEach(p => p.updateSize());
      updateUI(); 
      requestRedraw(); 
    }
  });
  
  $('decreasePocketSizeBtn').addEventListener('click', () => { 
    if (pocketSize > 0.1) { 
      pocketSize = Math.max(0.1, pocketSize - 0.05); 
      pockets.forEach(p => p.updateSize());
      updateUI(); 
      requestRedraw(); 
    }
  });

  $('showTrajectoryDuringSimulation').addEventListener('change', (e) => {
    showTrajInRun = e.target.checked;
    if (running) {
      showTrajInRun ? enableRunTraj() : disableRunTraj();
      requestRedraw();
    } else {
      // é™æ­¢æ€ä¸ä¾èµ–è¯¥å¼€å…³ï¼Œä»ç„¶å®æ—¶é¢„æµ‹ï¼›è¿™é‡Œåªåšåˆ·æ–°å³å¯
      disableRunTraj();
      requestRedraw();
    }
  });

  $('angleFineTune').addEventListener('input', (e) => { setAngleFineTune(parseFloat(e.target.value)); requestRedraw(); });

  // init
  updateUI();
  initGame();
  
  // å¤„ç†çª—å£å¤§å°å˜åŒ–
  window.addEventListener('resize', () => {
    requestRedraw();
  });
})();
</script>
</body>
</html>
