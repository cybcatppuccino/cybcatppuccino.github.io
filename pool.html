<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>台球狗运模拟器</title>
<style>
:root{--bg1:#1a2a6c;--bg2:#b21f1f;--felt:#27ae60;--wood:#8b4513;--panel-bg:rgba(0,0,0,.85);--control-bg:rgba(0,0,0,.7)}
*{box-sizing:border-box}body{font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;margin:0;padding:15px;min-height:100vh;color:#fff;background:linear-gradient(135deg,var(--bg1),var(--bg2),var(--bg1));display:flex;flex-direction:column;align-items:center;gap:12px;overflow-x:hidden}
h1{margin:0 0 6px;text-shadow:0 2px 4px rgba(0,0,0,.5);font-size:22px;text-align:center}
.container{width:100%;max-width:1200px;display:flex;flex-direction:column;gap:14px}
.content-wrapper{display:flex;gap:15px;width:100%}@media (max-width:900px){.content-wrapper{flex-direction:column}}
.table-section{flex:1;display:flex;flex-direction:column;gap:15px}
.canvas-container{position:relative;border:3px solid var(--wood);border-radius:8px;background:var(--felt);box-shadow:0 8px 16px rgba(0,0,0,.5);overflow:hidden;cursor:crosshair;touch-action:none}
canvas{display:block;width:100%;aspect-ratio:2/1;height:auto;background:var(--felt);touch-action:none}
.controls-below{background:var(--control-bg);border-radius:10px;padding:12px;display:grid;grid-template-columns:1fr 1fr;gap:15px}
@media (max-width:600px){.controls-below{grid-template-columns:1fr}}
.control-group{display:flex;flex-direction:column;gap:8px}
.control-label{font-weight:700;font-size:14px;display:flex;justify-content:space-between}
.control-value{color:#4ecdc4;min-width:50px;text-align:right}
input[type="range"]{width:100%;height:8px;border-radius:4px;background:#333;outline:none}
.side{width:320px;background:var(--panel-bg);border-radius:10px;padding:14px;box-shadow:0 4px 8px rgba(0,0,0,.3);display:flex;flex-direction:column;gap:12px;flex-shrink:0}
@media (max-width:900px){.side{width:100%}}
.grid{display:grid;grid-template-columns:1fr;gap:10px;flex:1}
.row2{display:grid;grid-template-columns:1fr 1fr;gap:10px}@media (max-width:600px){.row2{grid-template-columns:1fr}}
label{display:block;margin-bottom:6px;font-weight:800;font-size:13px}
.btns{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;margin-top:6px}
button{padding:8px 12px;font-size:13px;font-weight:700;border:none;border-radius:5px;cursor:pointer;color:#fff;transition:all .2s;box-shadow:0 3px 5px rgba(0,0,0,.2);background:linear-gradient(to bottom,#3498db,#2980b9);flex:1;min-width:80px}
button:hover{filter:brightness(1.07);transform:translateY(-1px);box-shadow:0 5px 8px rgba(0,0,0,.28)}
button:active{transform:translateY(1px)}
#resetBtn{background:linear-gradient(to bottom,#e74c3c,#c0392b)}#stopBtn{background:linear-gradient(to bottom,#95a5a6,#7f8c8d)}
.small{font-size:12px;opacity:.9;text-align:center}
.prediction-controls{display:flex;align-items:center;gap:6px;justify-content:center}
.chip{background:rgba(255,255,255,.09);padding:10px;border-radius:8px}
.info-panel{background:var(--panel-bg);padding:12px;border-radius:8px;text-align:center;font-size:13px}
.stats{display:flex;gap:10px;justify-content:space-around;flex-wrap:wrap;margin-top:8px}
.stat-item{background:rgba(0,0,0,.5);padding:7px 12px;border-radius:6px}
.progress-wrap{display:none;gap:8px;align-items:center}.progress-wrap.show{display:flex}
progress{width:100%;height:14px}
.disabled{opacity:.55;pointer-events:none}
.smart-aim-status{text-align:center;padding:8px;background:rgba(46,204,113,.2);border-radius:6px;display:none}
.smart-aim-status.show{display:block}
.collapsible-header{display:flex;justify-content:space-between;align-items:center;cursor:pointer;background:rgba(255,255,255,.1);padding:8px 10px;border-radius:6px;margin-bottom:8px}
.collapsible-header:hover{background:rgba(255,255,255,.15)}
.collapsible-content{display:none;padding:0 0 10px 0}
.collapsible-content.show{display:block}
.expand-icon{transition:transform .3s}
.expand-icon.rotated{transform:rotate(180deg)}
.section-chip{background:rgba(255,255,255,.09);padding:10px;border-radius:8px;margin-bottom:10px}
.main-stats{display:flex;justify-content:space-around;font-size:16px;font-weight:bold;margin:10px 0}
.main-stat-item{text-align:center}
.main-stat-value{color:#4ecdc4;display:block;font-size:20px}
.spot-marker{display:none}
</style>
</head>
<body>
<h1>台球狗运模拟器</h1>

<div class="container"><div class="content-wrapper">
  <div class="table-section">
    <div class="canvas-container">
      <canvas id="poolTable" width="800" height="400"></canvas>
      <div class="spot-marker" id="spotMarker"></div>
    </div>
    <div class="controls-below">
      <div class="control-group">
        <div class="control-label"><span>角度微调 (±1°):</span><span id="angleFineTuneValue" class="control-value">0.000</span>°</div>
        <input type="range" id="angleFineTune" min="-1" max="1" value="0" step="0.001"/>
      </div>
      <div class="control-group">
        <label><input type="checkbox" id="showTrajectoryDuringSimulation" style="width:auto;margin-right:8px;" checked/>运行时显示轨迹</label>
      </div>
    </div>
  </div>

  <div class="side" id="sidePanel">
    <div class="main-stats">
      <div class="main-stat-item">入袋数<br><span class="main-stat-value" id="pottedCount">0</span></div>
      <div class="main-stat-item">杆数<br><span class="main-stat-value" id="shotCount">0</span></div>
      <div class="main-stat-item">时间<br><span class="main-stat-value" id="timeCounter">0.00</span></div>
      <div class="main-stat-item">预测<br><span class="main-stat-value" id="predictedCount">0</span></div>
    </div>

    <div class="btns">
      <button id="stopBtn">停止所有球</button>
      <button id="resetBtn">重新开始</button>
    </div>

    <div class="section-chip">
      <div class="collapsible-header" onclick="toggleSection('physics')">
        <span>物理调节</span><span class="expand-icon" id="physics-icon">▼</span>
      </div>
      <div class="collapsible-content" id="physics-content">
        <div class="grid">
          <!-- ②：把白球初始速度挪到物理调节最先 -->
          <div class="chip">
            <label for="speedControl">白球初始速度: <span id="speedValue">12.00</span> 单位/秒</label>
            <input type="range" id="speedControl" min="0.1" max="30" value="12" step="0.01"/>
          </div>

          <div class="chip">
            <label for="massControl">白球质量: <span id="massValue">1.0</span></label>
            <input type="range" id="massControl" min="-1" max="0.5" value="0" step="0.01"/>
          </div>
          <div class="chip">
            <label for="frictionControl">桌面摩擦力: <span id="frictionValue">0.30</span></label>
            <input type="range" id="frictionControl" min="0" max="1" value="0.3" step="0.01"/>
          </div>
          <div class="row2">
            <div class="chip">
              <label for="collisionLossControl">碰撞能量损失: <span id="collisionLossValue">5</span>%</label>
              <input type="range" id="collisionLossControl" min="0" max="20" value="5" step="0.1"/>
            </div>
            <div class="chip">
              <label for="boundaryLossControl">边界能量损失: <span id="boundaryLossValue">5</span>%</label>
              <input type="range" id="boundaryLossControl" min="0" max="20" value="5" step="0.1"/>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="section-chip">
      <div class="collapsible-header" onclick="toggleSection('prediction')">
        <span>预测类</span><span class="expand-icon" id="prediction-icon">▼</span>
      </div>
      <div class="collapsible-content" id="prediction-content">
        <div class="grid">
          <div class="chip">
            <label for="predictionTimeControl">预测时间: <span id="predictionTimeValue">15</span>s</label>
            <input type="range" id="predictionTimeControl" min="5" max="50" value="15" step="5"/>
          </div>
          <div class="chip">
            <label>预测碰撞次数: <span id="maxCollisionsValue">2</span></label>
            <div class="prediction-controls">
              <button id="decreaseCollisionsBtn" style="padding:6px 10px;font-size:12px;">-</button>
              <span id="maxCollisionsDisplay">2</span>
              <button id="increaseCollisionsBtn" style="padding:6px 10px;font-size:12px;">+</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="section-chip">
      <div class="collapsible-header" onclick="toggleSection('table')">
        <span>桌面设置</span><span class="expand-icon" id="table-icon">▼</span>
      </div>
      <div class="collapsible-content" id="table-content">
        <div class="grid">
          <!-- ①：新增白球初始位置模式按钮 -->
          <div class="chip">
            <label>白球初始位置:</label>
            <div class="prediction-controls" style="justify-content:space-between;gap:10px;">
              <button id="cuePosModeBtn" style="flex:1;min-width:120px;padding:7px 10px;font-size:12px;">标准</button>
              <span class="small" style="opacity:.85;min-width:78px;text-align:right;"><span id="cuePosModeText">标准</span></span>
            </div>
          </div>

          <div class="chip">
            <label>袋口大小: <span id="pocketSizeValue">0.70</span></label>
            <div class="prediction-controls">
              <button id="decreasePocketSizeBtn" style="padding:6px 10px;font-size:12px;">-</button>
              <span id="pocketSizeDisplay">0.70</span>
              <button id="increasePocketSizeBtn" style="padding:6px 10px;font-size:12px;">+</button>
            </div>
          </div>

          <div class="chip">
            <label>球排列方式:</label>
            <div class="prediction-controls" style="flex-wrap:wrap;">
              <button id="layout1Btn" style="padding:6px 8px;font-size:12px;">一球</button>
              <button id="layout2Btn" style="padding:6px 8px;font-size:12px;">两球</button>
              <button id="layout3Btn" style="padding:6px 8px;font-size:12px;">三球</button>
              <button id="layout4Btn" style="padding:6px 8px;font-size:12px;">四球</button>
              <button id="layout6Btn" style="padding:6px 8px;font-size:12px;">六球</button>
              <button id="layout9Btn" style="padding:6px 8px;font-size:12px;">九球</button>
              <button id="layout10Btn" style="padding:6px 8px;font-size:12px;">十球</button>
              <button id="layout15Btn" style="padding:6px 8px;font-size:12px;">十五球</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="progress-wrap" id="smartProgressWrap">
      <progress id="smartProgress" value="0" max="2001"></progress>
      <div class="small" style="min-width:96px;text-align:right;"><span id="smartProgressText">0%</span></div>
    </div>
    <div class="smart-aim-status" id="smartAimStatus">正在帮你积攒狗运</div>

    <div class="info-panel">
      <div class="stats"><div class="stat-item">说明：瞎蒙一杆就行</div></div>
    </div>
  </div>
</div></div>

<script>
(()=>{const $=id=>document.getElementById(id),canvas=$('poolTable'),ctx=canvas.getContext('2d',{alpha:false,desynchronized:true});
const W=20,H=10,R=.25,RED_M=1,FPS=60,DT=1/FPS,STOP_V=.01,STOP_V2=STOP_V*STOP_V,EPS=1e-9,L=R,T=R,RR=W-R,BB=H-R;
const COLORS=['#E74C3C','#3498DB','#2ECC71','#F1C40F','#9B59B6','#1ABC9C','#E67E22','#34495E','#FF6B6B','#4ECDC4','#FFD700','#FF69B4','#8A2BE2','#00CED1','#ADFF2F','#FF4500','#20B2AA','#BA55D3','#CD5C5C','#4682B4'];
const hex2rgb=h=>[parseInt(h.slice(1,3),16),parseInt(h.slice(3,5),16),parseInt(h.slice(5,7),16)];
const rnd=(a,b)=>a+Math.random()*(b-a),clamp=(v,a,b)=>Math.min(b,Math.max(a,v));

let v0=12,mw=1,lossC=5,fric=.3,lossB=5,smartPredT=15,maxCol=2,pocketSize=.7;
let balls=[],pockets=[],running=false,showRunTraj=true,potted=0,simT=0,aimX=0,aimY=0,aimLocked=false,aiming=false,angFine=0,raf=0,needTraj=true,needBg=true;
let onlyWhiteTimer=null,cueScratchedThisShot=false,currentLayout='6',shotCount=0,predictedPots=0,spotX=2,spotY=H/2;

// ①：白球初始位置模式（标准/随机/自由）
const CUE_MODE={STD:0,RND:1,FREE:2};
let cueMode=CUE_MODE.STD, cueGhost={on:false,x:0,y:0};

const bg=document.createElement('canvas'),bgc=bg.getContext('2d',{alpha:false});
const traj=document.createElement('canvas'),tctx=traj.getContext('2d',{alpha:true});
let S=40,potRaf=0,potLast=0;

const linearToLog=v=>v>=0?1+v*9:Math.pow(10,v);
const setFine=v=>{angFine=v;$('angleFineTune').value=v;$('angleFineTuneValue').textContent=v.toFixed(3);needTraj=1;requestDraw();};

const cueModeText=()=>cueMode===CUE_MODE.STD?'标准':cueMode===CUE_MODE.RND?'随机':'自由';
const ui=()=>{$('speedValue').textContent=v0.toFixed(2);$('massValue').textContent=mw.toFixed(1);$('collisionLossValue').textContent=lossC;
$('frictionValue').textContent=fric.toFixed(2);$('boundaryLossValue').textContent=lossB;$('predictionTimeValue').textContent=smartPredT;
$('maxCollisionsValue').textContent=maxCol;$('maxCollisionsDisplay').textContent=maxCol;$('pocketSizeValue').textContent=pocketSize.toFixed(2);
$('pocketSizeDisplay').textContent=pocketSize.toFixed(2);$('pottedCount').textContent=potted;$('timeCounter').textContent=simT.toFixed(2);
$('showTrajectoryDuringSimulation').checked=showRunTraj;$('shotCount').textContent=shotCount;$('predictedCount').textContent=predictedPots;
$('cuePosModeBtn').textContent=cueModeText();$('cuePosModeText').textContent=cueModeText();};

const toWorld=e=>{const r=canvas.getBoundingClientRect(),ox=(typeof e.offsetX==='number')?e.offsetX:(e.clientX-r.left),oy=(typeof e.offsetY==='number')?e.offsetY:(e.clientY-r.top);
let x=ox/r.width*W,y=oy/r.height*H;return{x:clamp(x,L,RR),y:clamp(y,T,BB)};};

const shotAngle=(w,f=angFine)=>{if(!w||w.p||w.u) return null; const dx=aimX-w.x,dy=aimY-w.y;if(dx*dx+dy*dy<EPS)return null;return Math.atan2(dy,dx)+f*Math.PI/180;};
const requestDraw=()=>{if(raf)return;raf=requestAnimationFrame(()=>{raf=0;draw();});};

const makeBall=(x,y,color,isWhite=false)=>({x,y,vx:0,vy:0,r:R,m:isWhite?mw:RED_M,c:color,rgb:isWhite?[255,255,255]:hex2rgb(color),w:isWhite,p:0,u:0,ccr:0,potT:0,potPk:null,potVx:0,potVy:0,potSign:1});

const makePockets = () => {
  const r = pocketSize * .5, r2=r*r;
  pockets = [
    { x: L + 0.17, y: T + 0.17, r, r2, k: 'c', sx: -1, sy: -1 },
    { x: RR - 0.17, y: T + 0.17, r, r2, k: 'c', sx: 1, sy: -1 },
    { x: L + 0.17, y: BB - 0.17, r, r2, k: 'c', sx: -1, sy: 1 },
    { x: RR - 0.17, y: BB - 0.17, r, r2, k: 'c', sx: 1, sy: 1 },
    { x: W / 2, y: T + 0.1, r, r2, k: 't' },
    { x: W / 2, y: BB - 0.1, r, r2, k: 'b' }
  ];
};

const snapAllTinyVelToZero=()=>{for(const b of balls){if(b.p||b.u)continue; if(b.vx*b.vx+b.vy*b.vy<STOP_V2){b.vx=b.vy=0;}}};

const cueBreakSpot=()=>({x:spotX,y:spotY});
const pocketInwardOk=(pk,x,y)=>pk.k==='c'?((pk.sx<0?x>=pk.x:x<=pk.x)&&(pk.sy<0?y>=pk.y:y<=pk.y)):(pk.k==='t'?y>=pk.y:y<=pk.y);
const okPocketDir=(pk,vx,vy)=>{const s2=vx*vx+vy*vy; if(s2<STOP_V2) return false; return pk.k==='c'?(vx*pk.sx>0&&vy*pk.sy>0):(pk.k==='t'?vy<0:vy>0);};

// 所有袋：球心入袋圆 + 朝向/速度门槛
const inPocket=(pk,x,y,vx,vy)=>{
  if(!pocketInwardOk(pk,x,y)) return false;
  if(!okPocketDir(pk,vx,vy)) return false;
  const dx=x-pk.x,dy=y-pk.y;
  return dx*dx+dy*dy < pk.r2;
};

const canPlaceCueAt=(x,y)=>{
  const w=balls[0]; if(!w) return false;
  if(x<L+w.r||x>RR-w.r||y<T+w.r||y>BB-w.r) return false;
  for(const pk of pockets){const dx=x-pk.x,dy=y-pk.y;if(dx*dx+dy*dy < pk.r2 && pocketInwardOk(pk,x,y)) return false;}
  for(let i=1;i<balls.length;i++){const b=balls[i]; if(!b||b.p) continue; const dx=x-b.x,dy=y-b.y,md=w.r+b.r; if(dx*dx+dy*dy < (md*md + 1e-8)) return false;}
  return true;
};

const randomCuePos=()=>{
  for(let k=0;k<6000;k++){
    const x=rnd(L+R,RR-R),y=rnd(T+R,BB-R);
    if(canPlaceCueAt(x,y)) return {x,y};
  }
  return cueBreakSpot();
};

const respotCueBall=()=>{
  const w=balls[0]; if(!w) return;
  const {x:x0,y:y0}=cueBreakSpot(),step=Math.max(0.01,w.r*0.2); let x=x0,y=y0;
  if(!canPlaceCueAt(x,y)){let found=false;for(let xi=x0;xi<=RR-w.r;xi+=step){if(canPlaceCueAt(xi,y0)){x=xi;found=true;break;}} if(!found) x=RR-w.r;}
  
  // *** 修改点：根据 cueMode 决定 u 的值 ***
  const isFreeMode = (cueMode === CUE_MODE.FREE);
  Object.assign(w,{x,y,vx:0,vy:0,p:0,u:isFreeMode ? 1 : 0,potPk:null}); // 如果是自由模式，则 u=1 (未放置)
  
  // *** 修改点：只有在非自由模式下才自动设置 aimX/Y ***
  if (!isFreeMode) {
      if((aimX-w.x)*(aimX-w.x)+(aimY-w.y)*(aimY-w.y)<EPS){aimX=w.x+5;aimY=w.y;}
  } else {
      // 在自由模式下，重置 aimX/Y 以避免出现瞄准线
      aimX = w.x;
      aimY = w.y;
      aimLocked = false; // 确保未锁定
  }
};


// 进袋动画
const updatePotAnims=(dt)=>{
  let any=false;
  for(const b of balls){
    if(b.p!==2) continue;
    const pk=b.potPk;
    if(!pk){b.p=1;continue;}
    b.potT+=dt;
    const progress=Math.min(1,b.potT/0.55);
    const targetX=pk.x+(Math.random()-.5)*pk.r*0.3,targetY=pk.y+(Math.random()-.5)*pk.r*0.3;
    b.x=b.x+(targetX-b.x)*0.1; b.y=b.y+(targetY-b.y)*0.1;
    const damp=Math.max(0.1,1-progress); b.vx*=damp; b.vy*=damp;
    if(progress>=1||(Math.abs(b.x-pk.x)<.01&&Math.abs(b.y-pk.y)<.01)){
      b.p=1; b.x=pk.x+(Math.random()-.5)*pk.r*0.2; b.y=pk.y+(Math.random()-.5)*pk.r*0.2; b.r=R; b.potPk=null;
    } else any=true;
  }
  return any;
};
const startPotLoop=()=>{
  if(potRaf) return;
  potLast=performance.now();
  const loop=now=>{
    potRaf=0;
    const dt=Math.min(.05,(now-potLast)/1000||0); potLast=now;
    if(updatePotAnims(dt)){needTraj=1;requestDraw(); potRaf=requestAnimationFrame(loop);}
    else {needTraj=1;requestDraw();}
  };
  potRaf=requestAnimationFrame(loop);
};

const finishShotCommon=()=>{
  running=false; disableRunTraj(); aimLocked=false; setFine(0); onlyWhiteTimer=null;
  snapAllTinyVelToZero(); balls.forEach(b=>b.ccr=0);
  if(cueScratchedThisShot || (balls[0]&&balls[0].p&&balls[0].w)){respotCueBall();cueScratchedThisShot=false;}
  if(balls.some(b=>b.p===2)) startPotLoop();
  needTraj=1; requestDraw();
};

const ballsOverlap=(b1,b2)=>{const dx=b1.x-b2.x,dy=b1.y-b2.y;return dx*dx+dy*dy < (b1.r+b2.r)*(b1.r+b2.r);};
const separateBalls=(b1,b2)=>{const dx=b1.x-b2.x,dy=b1.y-b2.y,d=Math.hypot(dx,dy); if(d<EPS) return;
const md=b1.r+b2.r,ov=md-d,mx=(ov*dx/d)/2,my=(ov*dy/d)/2; b1.x+=mx;b1.y+=my;b2.x-=mx;b2.y-=my;};
const resolveOverlaps=()=>{let has=true,it=0;while(has&&it<120){has=false;for(let i=0;i<balls.length;i++)for(let j=i+1;j<balls.length;j++){if(balls[i].p||balls[j].p||balls[i].u||balls[j].u)continue;if(ballsOverlap(balls[i],balls[j])){separateBalls(balls[i],balls[j]);has=true;}}it++;}};

// 布局（保持你原来的规则）
const createBallsLayout = (layout) => {
  balls = [];
  const jitter = 0.02;
  balls.push(makeBall(spotX + rnd(-jitter, jitter), spotY + rnd(-jitter, jitter), '#fff', true));

  const numMap = { 1: 1, 2: 2, 3: 3, 4: 4, 6: 6, 9: 9, 10: 10, 15: 15 };
  const n = numMap[layout] ?? 6;

  const startX = 15, centerY = H / 2;
  const dx = 2 * R * 1.02, dy = Math.sqrt(3) * R * 1.02;

  let pts = [];

  if (layout === '2') {
    pts = [{ x: startX, y: centerY - dy / 2 },{ x: startX, y: centerY + dy / 2 }];
  } else if (layout === '4') {
    pts = [{ x: startX, y: centerY },{ x: startX + dx, y: centerY - dy / 2 }, { x: startX + dx, y: centerY + dy / 2 },{ x: startX + 2 * dx, y: centerY }];
  } else if (layout === '9') {
    pts = [
      { x: startX + 2 * dx, y: centerY },
      { x: startX + dx, y: centerY - dy/2 }, { x: startX + dx, y: centerY + dy/2 },
      { x: startX, y: centerY - dy }, { x: startX, y: centerY }, { x: startX, y: centerY + dy },
      { x: startX - dx, y: centerY - dy/2 }, { x: startX - dx, y: centerY + dy/2 },
      { x: startX - 2 * dx, y: centerY }
    ];
  } else {
    let rows = 1;
    while (rows * (rows + 1) / 2 < n) rows++;
    const grid = [];
    for (let r = 0; r < rows; r++) for (let j = 0; j <= r; j++) grid.push({ x: startX + r * dx, y: centerY + (j - r / 2) * dy });
    pts = grid.slice(0, n);
  }

  const colors = [...COLORS];
  for (let i = colors.length - 1; i > 0; i--) { const j = (Math.random() * (i + 1)) | 0; [colors[i], colors[j]] = [colors[j], colors[i]]; }

  const placed = [], tryPlace = (x0, y0) => {
    for (let k = 0; k < 60; k++) {
      const x = clamp(x0 + rnd(-jitter, jitter), L + R, RR - R);
      const y = clamp(y0 + rnd(-jitter, jitter), T + R, BB - R);
      let ok = true;
      for (const b of placed) { const dx = x - b.x, dy = y - b.y; if (dx*dx + dy*dy < (2*R)*(2*R) - 1e-10) { ok = false; break; } }
      if (ok) return { x, y };
    }
    return { x: clamp(x0, L + R, RR - R), y: clamp(y0, T + R, BB - R) };
  };

  for (let i = 0; i < n; i++) {
    const { x, y } = tryPlace(pts[i].x, pts[i].y);
    const b = makeBall(x, y, colors[i % colors.length]);
    placed.push(b); balls.push(b);
  }
  resolveOverlaps();
};

const applyCueModeOnNewGame=()=>{
  const w=balls[0]; if(!w) return;
  cueGhost.on=false;

  if(cueMode===CUE_MODE.STD){
    w.u=0; // 标准：保持现状（布局已经放好）
    aimX=w.x+5; aimY=w.y;
  }else if(cueMode===CUE_MODE.RND){
    const p=randomCuePos();
    Object.assign(w,{x:p.x,y:p.y,vx:0,vy:0,p:0,u:0,potPk:null});
    aimX=w.x+5; aimY=w.y;
  }else{
    // 自由：开局需要放置白球（不显示实体白球；只在可放置时显示虚化白球）
    Object.assign(w,{vx:0,vy:0,p:0,u:1,potPk:null}); // u=1 表示未放置
    aimLocked=false; aiming=false; setFine(0);
    // *** 修改点：放置后不立即设置 aimX/Y ***
    // aimX 和 aimY 将在放置后首次点击时设置
  }
};


const init=()=>{
  running=false;potted=0;shotCount=0;simT=0;aimLocked=false;aiming=false;cueScratchedThisShot=false;setFine(0);makePockets();
  createBallsLayout(currentLayout);
  balls.forEach(b=>b.ccr=0);
  applyCueModeOnNewGame();
  needBg=needTraj=1;ui();requestDraw();
};

const stepBall=b=>{if(b.p||b.u) return 0;
const s2=b.vx*b.vx+b.vy*b.vy;
if(s2>EPS){const s=Math.sqrt(s2),ns=Math.max(0,s-fric*DT),k=ns/s; b.vx*=k;b.vy*=k; if(b.vx*b.vx+b.vy*b.vy<STOP_V2){b.vx=b.vy=0;}}
b.x+=b.vx*DT; b.y+=b.vy*DT;
const blf=(100-lossB)/100; let hit=0;
if(b.x-b.r<L){b.x=L+b.r;b.vx=-b.vx*blf;hit=1;} else if(b.x+b.r>RR){b.x=RR-b.r;b.vx=-b.vx*blf;hit=1;}
if(b.y-b.r<T){b.y=T+b.r;b.vy=-b.vy*blf;hit=1;} else if(b.y+b.r>BB){b.y=BB-b.r;b.vy=-b.vy*blf;hit=1;}
return hit;};

const collide=(a,b)=>{if(a.p||b.p||a.u||b.u) return 0;
const dx=b.x-a.x,dy=b.y-a.y,md=a.r+b.r,d2=dx*dx+dy*dy;
if(d2>=md*md||d2<EPS) return 0;
const d=Math.sqrt(d2),nx=dx/d,ny=dy/d,tx=-ny,ty=nx;
const v1n=a.vx*nx+a.vy*ny,v1t=a.vx*tx+a.vy*ty,v2n=b.vx*nx+b.vy*ny,v2t=b.vx*tx+b.vy*ty,m1=a.m,m2=b.m;
const v1n2=(v1n*(m1-m2)+2*m2*v2n)/(m1+m2),v2n2=(v2n*(m2-m1)+2*m1*v1n)/(m1+m2),elf=(100-lossC)/100;
a.vx=(v1n2*nx+v1t*tx)*elf; a.vy=(v1n2*ny+v1t*ty)*elf;
b.vx=(v2n2*nx+v2t*tx)*elf; b.vy=(v2n2*ny+v2t*ty)*elf;
const ov=(md-d)/2; a.x-=ov*nx;a.y-=ov*ny; b.x+=ov*nx;b.y+=ov*ny; return 1;};

const potBall=(b,pk,countUI)=>{
  if(b.p||b.u) return;
  b.p=2; b.potPk=pk; b.potT=0; b.potVx=b.vx; b.potVy=b.vy;
  const rx=b.x-pk.x, ry=b.y-pk.y, cross=b.vx*ry - b.vy*rx; b.potSign=(cross>=0)?1:-1;
  b.vx*=0.85; b.vy*=0.85;
  if(countUI){potted++; $('pottedCount').textContent=potted;}
};

const checkPots=countUI=>{
  for(const b of balls){
    if(b.p||b.w||b.u) continue;
    for(const pk of pockets){ if(inPocket(pk,b.x,b.y,b.vx,b.vy)){ potBall(b,pk,countUI); break; } }
  }
};

const checkCueScratch=countUI=>{
  const w=balls[0]; if(!w||w.p||w.u) return false;
  for(const pk of pockets){
    if(inPocket(pk,w.x,w.y,w.vx,w.vy)){
      cueScratchedThisShot=true;
      potBall(w,pk,false);
      return true;
    }
  }
  return false;
};

// ③：simPred 小优化：unplaced 视作“不可用”，并减少不必要的 hypot；其它逻辑保持一致
function simPred({includeAim,recordSet=null,sample=1,maxSteps=60000}){
  const n=balls.length;
  const x=new Float64Array(n),y=new Float64Array(n),vx=new Float64Array(n),vy=new Float64Array(n);
  const p=new Uint8Array(n),wA=new Uint8Array(n),cc=new Uint16Array(n),start=new Uint16Array(n);
  let wi=-1;
  for(let i=0;i<n;i++){
    const b=balls[i];
    x[i]=b.x;y[i]=b.y;vx[i]=b.vx;vy[i]=b.vy;p[i]=(b.p||b.u)?1:0;wA[i]=b.w?1:0;cc[i]=start[i]=b.ccr||0;
    if(b.w)wi=i;
  }
  if(includeAim&&wi>=0&&!p[wi] && (vx[wi]*vx[wi]+vy[wi]*vy[wi])<STOP_V2){
    const dx=aimX-x[wi],dy=aimY-y[wi],d2=dx*dx+dy*dy;
    if(d2>EPS){const ang=Math.atan2(dy,dx)+angFine*Math.PI/180; vx[wi]=v0*Math.cos(ang);vy[wi]=v0*Math.sin(ang);}
  }
  const want=i=>!recordSet||recordSet.has(i);
  const trajArr=Array.from({length:n},(_,i)=>({pts:[],rgb:balls[i].rgb}));
  const blf=(100-lossB)/100,elf=(100-lossC)/100;

  let potCount=0;
  for(let step=0;step<maxSteps;step++){
    let any=0; for(let i=0;i<n;i++) if(!p[i] && (vx[i]*vx[i]+vy[i]*vy[i])>=STOP_V2){any=1;break;} if(!any) break;
    if(step%sample===0) for(let i=0;i<n;i++) if(want(i)&&!p[i]&&cc[i]<=start[i]+maxCol) trajArr[i].pts.push(x[i],y[i]);

    for(let i=0;i<n;i++){
      if(p[i]) continue;
      const s2=vx[i]*vx[i]+vy[i]*vy[i];
      if(s2>EPS){const s=Math.sqrt(s2),ns=Math.max(0,s-fric*DT),k=ns/s;vx[i]*=k;vy[i]*=k; if(vx[i]*vx[i]+vy[i]*vy[i]<STOP_V2){vx[i]=vy[i]=0;}}
      x[i]+=vx[i]*DT; y[i]+=vy[i]*DT;
      let hit=0;
      if(x[i]-R<L){x[i]=L+R;vx[i]=-vx[i]*blf;hit=1;} else if(x[i]+R>RR){x[i]=RR-R;vx[i]=-vx[i]*blf;hit=1;}
      if(y[i]-R<T){y[i]=T+R;vy[i]=-vy[i]*blf;hit=1;} else if(y[i]+R>BB){y[i]=BB-R;vy[i]=-vy[i]*blf;hit=1;}
      if(hit) cc[i]++;
    }

    for(let i=0;i<n;i++)for(let j=i+1;j<n;j++){
      if(p[i]||p[j]) continue;
      const dx=x[j]-x[i],dy=y[j]-y[i],md=2*R,d2=dx*dx+dy*dy;
      if(d2>=md*md||d2<EPS) continue;
      const d=Math.sqrt(d2),nx=dx/d,ny=dy/d,tx=-ny,ty=nx;
      const v1n=vx[i]*nx+vy[i]*ny,v1t=vx[i]*tx+vy[i]*ty,v2n=vx[j]*nx+vy[j]*ny,v2t=vx[j]*tx+vy[j]*ty;
      const m1=balls[i].m,m2=balls[j].m;
      const v1n2=(v1n*(m1-m2)+2*m2*v2n)/(m1+m2),v2n2=(v2n*(m2-m1)+2*m1*v1n)/(m1+m2);
      vx[i]=(v1n2*nx+v1t*tx)*elf;vy[i]=(v1n2*ny+v1t*ty)*elf;
      vx[j]=(v2n2*nx+v2t*tx)*elf;vy[j]=(v2n2*ny+v2t*ty)*elf;
      const ov=(md-d)/2;x[i]-=ov*nx;y[i]-=ov*ny;x[j]+=ov*nx;y[j]+=ov*ny;
      cc[i]++;cc[j]++;
    }

    for(let i=0;i<n;i++){
      if(p[i]||wA[i]) continue;
      for(const pk of pockets){
        if(inPocket(pk,x[i],y[i],vx[i],vy[i])){
          p[i]=1;
          if(!recordSet||recordSet.has(i)) potCount++;
          break;
        }
      }
    }
    if(wi>=0&&!p[wi]) for(const pk of pockets){ if(inPocket(pk,x[wi],y[wi],vx[wi],vy[wi])){p[wi]=1;break;} }
  }

  if(includeAim && !recordSet) { predictedPots=potCount; ui(); }
  return trajArr;
}

const resize=()=>{const dpr=Math.min(2,window.devicePixelRatio||1),w=canvas.clientWidth||800,h=w*(H/W);
canvas.style.height=h+'px';const pxW=Math.round(w*dpr),pxH=Math.round(h*dpr);
if(canvas.width===pxW&&canvas.height===pxH)return;
canvas.width=pxW;canvas.height=pxH;bg.width=pxW;bg.height=pxH;traj.width=pxW;traj.height=pxH;
ctx.setTransform(dpr,0,0,dpr,0,0);bgc.setTransform(dpr,0,0,dpr,0,0);tctx.setTransform(dpr,0,0,dpr,0,0);
S=w/W;needBg=needTraj=1;requestDraw();};

const drawPocket=pk=>{
  const x=pk.x*S,y=pk.y*S,r=pk.r*S;
  bgc.beginPath(); bgc.arc(x,y,r,0,Math.PI*2); bgc.fillStyle='#000'; bgc.fill();
  bgc.beginPath(); bgc.arc(x,y,r*.7,0,Math.PI*2); bgc.fillStyle='#333'; bgc.fill();
};

const drawBg=()=>{
  const w=canvas.clientWidth,h=canvas.clientHeight;
  bgc.clearRect(0,0,w,h);
  bgc.fillStyle='#27ae60'; bgc.fillRect(0,0,w,h);
  bgc.strokeStyle='#8b4513'; bgc.lineWidth=6; bgc.strokeRect(0,0,w,h);
  bgc.strokeStyle='rgba(0,0,0,.85)'; bgc.lineWidth=2;
  bgc.strokeRect(L*S,T*S,(W-2*R)*S,(H-2*R)*S);

  bgc.beginPath(); bgc.arc(spotX*S,spotY*S,3,0,Math.PI*2);
  bgc.fillStyle='rgba(255,255,255,.85)'; bgc.fill();

  for(const pk of pockets) drawPocket(pk);
  needBg=0;
};

const strokePoly=(pts,rgb,dynamic)=>{if(!pts||pts.length<4)return;
const chunks=dynamic?10:1,n=pts.length/2;
for(let c=0;c<chunks;c++){
  const a0=c/chunks,a1=(c+1)/chunks,i0=Math.floor(a0*(n-1)),i1=Math.max(i0+1,Math.floor(a1*(n-1)));
  const alpha=dynamic?Math.max(.12,1-a0*.9):.65;
  tctx.strokeStyle=`rgba(${rgb[0]},${rgb[1]},${rgb[2]},${alpha})`;tctx.lineWidth=2;
  tctx.beginPath();tctx.moveTo(pts[i0*2]*S,pts[i0*2+1]*S);
  for(let i=i0+1;i<=i1;i++)tctx.lineTo(pts[i*2]*S,pts[i*2+1]*S);
  tctx.stroke();
}};

const drawTrajLayer=()=>{
  const w=canvas.clientWidth,h=canvas.clientHeight; tctx.clearRect(0,0,w,h);
  const wb=balls[0];
  if(wb && wb.u){ needTraj=0; return; } // 自由放置未完成：不画轨迹
  if(running){
    if(showRunTraj&&runTrajEnabled) for(let i=0;i<runTraj.length;i++){const t=runTraj[i]; if(t&&balls[i]&&!balls[i].p&&!balls[i].u) strokePoly(t.pts,t.rgb,false);}
  }else{
    const t=simPred({includeAim:true,sample:1});
    for(let i=0;i<t.length;i++) if(!balls[i].p&&!balls[i].u) strokePoly(t[i].pts,t[i].rgb,true);
  }
  needTraj=0;
};

const drawBalls=()=>{
  for(const b of balls){
    if(b.p===1||b.u) continue;
    ctx.beginPath(); ctx.arc(b.x*S,b.y*S,b.r*S,0,Math.PI*2);
    ctx.fillStyle=b.w?'#fff':b.c; ctx.fill();
    ctx.strokeStyle='#000'; ctx.lineWidth=1; ctx.stroke();
    if(!b.w && b.p!==2){
      ctx.beginPath(); ctx.arc(b.x*S-b.r*S*.3,b.y*S-b.r*S*.3,b.r*S*.2,0,Math.PI*2);
      ctx.fillStyle='rgba(255,255,255,.9)'; ctx.fill();
    }
  }
};

const drawCueGhost=()=>{
  const w=balls[0]; if(!w||!w.u||!cueGhost.on) return;
  ctx.save();
  ctx.globalAlpha=0.35;
  ctx.beginPath(); ctx.arc(cueGhost.x*S,cueGhost.y*S,R*S,0,Math.PI*2);
  ctx.fillStyle='#fff'; ctx.fill();
  ctx.globalAlpha=0.55; ctx.strokeStyle='#000'; ctx.lineWidth=1; ctx.stroke();
  ctx.restore();
};

const drawAim=()=>{
  if(running) return;
  const w=balls[0]; if(!w||w.p||w.u) return;
  const ang=shotAngle(w); if(ang==null) return;
  const ux=Math.cos(ang),uy=Math.sin(ang);
  ctx.beginPath(); ctx.moveTo(w.x*S,w.y*S); ctx.lineTo((w.x+ux*5)*S,(w.y+uy*5)*S);
  ctx.strokeStyle='rgba(255,255,255,.7)'; ctx.lineWidth=2; ctx.stroke();
  ctx.beginPath(); ctx.moveTo(w.x*S,w.y*S); ctx.lineTo((w.x-ux*3)*S,(w.y-uy*3)*S);
  ctx.strokeStyle='rgba(255,0,0,.8)'; ctx.lineWidth=3; ctx.stroke();
};

const draw=()=>{if(needBg)drawBg(); if(needTraj)drawTrajLayer();
const w=canvas.clientWidth,h=canvas.clientHeight;
ctx.clearRect(0,0,w,h); ctx.drawImage(bg,0,0,w,h); ctx.drawImage(traj,0,0,w,h);
drawBalls(); drawCueGhost(); drawAim();
};

let runTrajEnabled=false,runTraj=[];
const enableRunTraj=()=>{
  runTrajEnabled=true; runTraj=Array(balls.length).fill(null);
  const moving=new Set();
  for(let i=0;i<balls.length;i++){const b=balls[i]; if(!b.p&&!b.u&&(b.vx*b.vx+b.vy*b.vy)>STOP_V2) moving.add(i);}
  const t=simPred({includeAim:false,recordSet:moving,sample:2});
  moving.forEach(i=>runTraj[i]=t[i]); needTraj=1;
};
const updateRunTraj=dirty=>{if(!showRunTraj||!runTrajEnabled||!dirty.size) return;
  const t=simPred({includeAim:false,recordSet:dirty,sample:2}); dirty.forEach(i=>runTraj[i]=t[i]); needTraj=1;
};
const disableRunTraj=()=>{runTrajEnabled=false;runTraj=[];needTraj=1;};

const tick=()=>{
  if(!running) return;
  const dirty=new Set();
  for(let i=0;i<balls.length;i++){const b=balls[i]; if(b.p||b.u) continue; if(stepBall(b)){b.ccr++;dirty.add(i);}}
  for(let i=0;i<balls.length;i++)for(let j=i+1;j<balls.length;j++){
    if(collide(balls[i],balls[j])){balls[i].ccr++;balls[j].ccr++;dirty.add(i);dirty.add(j);}
  }

  checkPots(true);
  if(checkCueScratch(true)) dirty.add(0);
  if(dirty.size) updateRunTraj(dirty);

  updatePotAnims(DT);

  simT+=DT; $('timeCounter').textContent=simT.toFixed(2);

  const onlyWhiteLeft=balls.length>0 && balls.every(b=>b.p||b.u||b.w);
  if(onlyWhiteLeft && !onlyWhiteTimer) onlyWhiteTimer=0;
  if(onlyWhiteTimer!==null){
    onlyWhiteTimer+=DT;
    if(onlyWhiteTimer>=4.0){running=false;disableRunTraj();aimLocked=false;setFine(0);onlyWhiteTimer=null;init();requestDraw();return;}
  }

  const stopped=balls.every(b=>b.p||b.u||(b.vx*b.vx+b.vy*b.vy)<STOP_V2);
  if(stopped){
    finishShotCommon();
    const reds=balls.slice(1);
    if(reds.every(b=>b.p)) {
      potted=0; $('pottedCount').textContent=potted;
      setTimeout(init,1000);
    }
    return;
  }
  requestDraw(); requestAnimationFrame(tick);
};

// ③：SmartAim 提速：复用 typed arrays，避免每个角度都 new；同时减少 hypot 判断
const smart={running:false,cancel:false};
const setSmartUI=on=>{smart.running=on;$('smartProgressWrap').classList.toggle('show',on);$('smartAimStatus').classList.toggle('show',on);
$('stopBtn').classList.toggle('disabled',on);$('resetBtn').classList.toggle('disabled',on);};

function buildBase(){
  const n=balls.length;
  const bx=new Float64Array(n),by=new Float64Array(n),bvx=new Float64Array(n),bvy=new Float64Array(n),bm=new Float64Array(n),bp=new Uint8Array(n),bw=new Uint8Array(n);
  let wi=0;
  for(let i=0;i<n;i++){
    const b=balls[i];
    bx[i]=b.x;by[i]=b.y;bvx[i]=b.vx;bvy[i]=b.vy;bm[i]=b.m;bp[i]=(b.p||b.u)?1:0;bw[i]=b.w?1:0;
    if(b.w)wi=i;
  }
  const pi=[],pj=[]; for(let i=0;i<n;i++)for(let j=i+1;j<n;j++){pi.push(i);pj.push(j);}
  return{n,wi,bx,by,bvx,bvy,bm,bp,bw,pi:new Uint16Array(pi),pj:new Uint16Array(pj)};
}

function evalAngleReuse(base,deg,buf,steps,blf,elf){
  const {n,wi,pi,pj}=base;
  const {x,y,vx,vy,p}=buf;

  x.set(base.bx); y.set(base.by); vx.set(base.bvx); vy.set(base.bvy); p.set(base.bp);

  for(let i=0;i<n;i++){if(p[i])continue; if(vx[i]*vx[i]+vy[i]*vy[i]<STOP_V2){vx[i]=vy[i]=0;}}
  if(!p[wi] && (vx[wi]*vx[wi]+vy[wi]*vy[wi])<STOP_V2){
    const dx=aimX-x[wi],dy=aimY-y[wi],d2=dx*dx+dy*dy;
    if(d2>EPS){const a=Math.atan2(dy,dx)+deg*Math.PI/180; vx[wi]=v0*Math.cos(a);vy[wi]=v0*Math.sin(a);}
  }

  let pot=0,last=0,scratched=false;
  for(let step=0;step<steps;step++){
    let any=0; for(let i=0;i<n;i++) if(!p[i] && (vx[i]*vx[i]+vy[i]*vy[i])>=STOP_V2){any=1;break;} if(!any) break;

    for(let i=0;i<n;i++){
      if(p[i]) continue;
      const s2=vx[i]*vx[i]+vy[i]*vy[i];
      if(s2>EPS){const s=Math.sqrt(s2),ns=Math.max(0,s-fric*DT),k=ns/s;vx[i]*=k;vy[i]*=k; if(vx[i]*vx[i]+vy[i]*vy[i]<STOP_V2){vx[i]=vy[i]=0;}}
      x[i]+=vx[i]*DT; y[i]+=vy[i]*DT;
      if(x[i]-R<L){x[i]=L+R;vx[i]=-vx[i]*blf;} else if(x[i]+R>RR){x[i]=RR-R;vx[i]=-vx[i]*blf;}
      if(y[i]-R<T){y[i]=T+R;vy[i]=-vy[i]*blf;} else if(y[i]+R>BB){y[i]=BB-R;vy[i]=-vy[i]*blf;}
    }

    for(let k=0;k<pi.length;k++){
      const i=pi[k],j=pj[k];
      if(p[i]||p[j]) continue;
      const dx=x[j]-x[i],dy=y[j]-y[i],md=2*R,d2=dx*dx+dy*dy;
      if(d2>=md*md||d2<EPS) continue;
      const d=Math.sqrt(d2),nx=dx/d,ny=dy/d,tx=-ny,ty=nx;
      const v1n=vx[i]*nx+vy[i]*ny,v1t=vx[i]*tx+vy[i]*ty,v2n=vx[j]*nx+vy[j]*ny,v2t=vx[j]*tx+vy[j]*ty;
      const m1=base.bm[i],m2=base.bm[j];
      const v1n2=(v1n*(m1-m2)+2*m2*v2n)/(m1+m2),v2n2=(v2n*(m2-m1)+2*m1*v1n)/(m1+m2);
      vx[i]=(v1n2*nx+v1t*tx)*elf;vy[i]=(v1n2*ny+v1t*ty)*elf;
      vx[j]=(v2n2*nx+v2t*tx)*elf;vy[j]=(v2n2*ny+v2t*ty)*elf;
      const ov=(md-d)/2;x[i]-=ov*nx;y[i]-=ov*ny;x[j]+=ov*nx;y[j]+=ov*ny;
    }

    const t=(step+1)*DT;
    if(!p[wi]){
      for(const pk of pockets){ if(inPocket(pk,x[wi],y[wi],vx[wi],vy[wi])){scratched=true;p[wi]=1;break;} }
      if(scratched) break;
    }

    for(let i=0;i<n;i++){
      if(p[i]||i===wi) continue;
      for(const pk of pockets){
        if(inPocket(pk,x[i],y[i],vx[i],vy[i])){
          p[i]=1;
          if(!base.bp[i]){pot++; if(t>last) last=t;}
          break;
        }
      }
    }
  }
  return{pot,last,scratched};
}

async function smartAim(){
  if(running||smart.running) return;
  const w=balls[0]; if(!w||w.p||w.u) return;
  if(shotAngle(w,0)==null) return;

  smart.cancel=false; setSmartUI(true);
  const dis=['angleFineTune','speedControl','massControl','frictionControl','collisionLossControl','boundaryLossControl'];
  dis.forEach(id=>$(id).disabled=true);

  const total=2001;
  $('smartProgress').max=total; $('smartProgress').value=0; $('smartProgressText').textContent='0%';

  const base=buildBase();
  const buf={x:new Float64Array(base.n),y:new Float64Array(base.n),vx:new Float64Array(base.n),vy:new Float64Array(base.n),p:new Uint8Array(base.n)};
  const steps=Math.max(1,Math.floor(smartPredT/DT));
  const blf=(100-lossB)/100,elf=(100-lossC)/100;

  let best=0,bestPot=-1,bestT=1e9,sawNonScratch=false,sawNonScratchPot=false;

  for(let idx=0;idx<total&&!smart.cancel;){
    const t0=performance.now();
    for(let batch=0;idx<total&&batch<140;batch++,idx++){
      const deg=-1+idx*.001,r=evalAngleReuse(base,deg,buf,steps,blf,elf);
      if(r.scratched) continue;
      sawNonScratch=true; if(r.pot>0) sawNonScratchPot=true;
      if(r.pot>bestPot || (r.pot===bestPot && r.last<bestT)){bestPot=r.pot;bestT=r.last;best=deg;}
      if(performance.now()-t0>10) break;
    }
    $('smartProgress').value=idx;
    $('smartProgressText').textContent=Math.floor(idx/total*100)+'%';
    await new Promise(requestAnimationFrame);
  }

  setSmartUI(false); dis.forEach(id=>$(id).disabled=false);
  if(smart.cancel) return;
  if(!sawNonScratch || !sawNonScratchPot) best=0;
  setFine(best); aimLocked=true; setTimeout(shoot,300);
}

const shoot=()=>{
  if(running||smart.running) return;
  const w=balls[0]; if(!w||w.p||w.u) return;
  const ang=shotAngle(w); if(ang==null) return;

  cueScratchedThisShot=false;
  w.vx=v0*Math.cos(ang); w.vy=v0*Math.sin(ang);
  balls.forEach(b=>b.ccr=0);
  running=true;
  showRunTraj?enableRunTraj():disableRunTraj();
  shotCount++;
  ui();
  requestAnimationFrame(tick);
};

const stopAll=()=>{for(const b of balls){b.vx=b.vy=0;} finishShotCommon();};

// --- 替换开始 ---
// pointer（①：自由模式开局放置白球）
// *** 修改点：添加一个标志，用于标识自由模式下的放置后等待瞄准状态 ***
let freeModePlacedButNotAimed = false;

const placeCueIfFree=(e)=>{
  const w=balls[0]; if(!w||!w.u) return false;
  const p=toWorld(e);
  if(canPlaceCueAt(p.x,p.y)){
    Object.assign(w,{x:p.x,y:p.y,vx:0,vy:0,u:0,p:0,potPk:null}); // 放置成功，u=0
    cueGhost.on=false;
    
    // *** 修改点：设置初始 aimX/Y 为白球位置，并标记等待瞄准 ***
    aimX = w.x;
    aimY = w.y;
    freeModePlacedButNotAimed = true;
    
    needTraj=1; requestDraw();
    return true;
  }
  return false;
};

canvas.addEventListener('pointerdown',e=>{
  if(running||smart.running) return;
  if(e.pointerType!=='mouse') e.preventDefault();
  try{canvas.setPointerCapture(e.pointerId);}catch{}

  const w=balls[0];
  if(w && w.u){
    placeCueIfFree(e); // 自由放置：点击即尝试落位
    return;
  }
  
  // *** 新增逻辑：处理自由模式下放置后但未瞄准的情况 ***
  if (freeModePlacedButNotAimed) {
      // 点击：开始瞄准
      aiming=true;
      aimLocked=false;
      // aimX/Y 已经在 pointermove 中更新了，这里不需要再设置
      needTraj=1; requestDraw();
      return;
  }

  // 默认行为：开始瞄准
  aiming=true; aimLocked=false;
  const p=toWorld(e); aimX=p.x; aimY=p.y; needTraj=1; requestDraw();
},{passive:false});

canvas.addEventListener('pointermove',e=>{
  if(running||smart.running) return;
  if(e.pointerType!=='mouse') e.preventDefault();

  const w=balls[0];
  if(w && w.u){
    const p=toWorld(e);
    if(canPlaceCueAt(p.x,p.y)){cueGhost.on=true;cueGhost.x=p.x;cueGhost.y=p.y;}
    else cueGhost.on=false;
    needTraj=1; requestDraw();
    return;
  }
  
  // *** 关键修改：在自由模式放置后 或 正常瞄准时，都应更新 aimX/Y 以显示轨迹 ***
  // 只要不是在运行中且白球存在且未进袋/未放置
  if (!w || w.p || w.u) return;
  
  const p=toWorld(e);
  // 更新 aimX/Y 以供轨迹计算使用
  aimX=p.x; aimY=p.y; 
  
  // 但是，只有在用户明确开始瞄准 (aiming=true) 后，才锁定方向并准备发射
  // 如果是自由模式放置后被动更新，则 aimLocked 应为 false
  if (aiming) {
       // 用户正在拖动鼠标进行瞄准，保持 aimLocked 为 false 直到 pointerup
       needTraj=1; requestDraw();
  } else if (freeModePlacedButNotAimed) {
       // 自由模式放置后，鼠标移动时被动更新 aimX/Y，用于显示预览轨迹
       // aimLocked 保持 false，aiming 也是 false
       needTraj=1; requestDraw();
  } else {
       // 这是正常模式下的鼠标移动预览（例如，标准模式）
       needTraj=1; requestDraw();
  }
},{passive:false});

canvas.addEventListener('pointerup',e=>{
  if(running||smart.running) return;
  if(e.pointerType!=='mouse') e.preventDefault();

  const w=balls[0];
  if(w && w.u){ return; } // 自由放置阶段：松手不触发瞄准/智能
  
  // *** 新增逻辑：处理自由模式下放置后但未瞄准的情况 ***
  if (freeModePlacedButNotAimed) {
      // 松开：确认瞄准并触发智能瞄准
      freeModePlacedButNotAimed = false; // 重置标志
      aiming=false; // 结束瞄准状态
      aimLocked=true; // 锁定当前 aimX/Y
      smartAim();
      return;
  }
  
  // 默认行为：结束瞄准并触发智能瞄准
  aiming=false; aimLocked=true; smartAim();
},{passive:false});

canvas.addEventListener('pointercancel',()=>{
    // *** 新增逻辑：取消时也重置标志 ***
    freeModePlacedButNotAimed = false; 
    aiming=false;
},{passive:false});
// --- 替换结束 ---


// controls
$('stopBtn').addEventListener('click',stopAll);
$('resetBtn').addEventListener('click',init);
$('speedControl').addEventListener('input',e=>{v0=+e.target.value;ui();needTraj=1;requestDraw();});
$('massControl').addEventListener('input',e=>{mw=linearToLog(+e.target.value);balls[0].m=mw;ui();needTraj=1;requestDraw();});
$('collisionLossControl').addEventListener('input',e=>{lossC=+e.target.value|0;ui();needTraj=1;requestDraw();});
$('frictionControl').addEventListener('input',e=>{fric=+e.target.value;ui();needTraj=1;requestDraw();});
$('boundaryLossControl').addEventListener('input',e=>{lossB=+e.target.value|0;ui();needTraj=1;requestDraw();});
$('predictionTimeControl').addEventListener('input',e=>{smartPredT=+e.target.value|0;ui();});
$('increaseCollisionsBtn').addEventListener('click',()=>{if(maxCol<10){maxCol++;ui();if(running&&showRunTraj)enableRunTraj();needTraj=1;requestDraw();}});
$('decreaseCollisionsBtn').addEventListener('click',()=>{if(maxCol>0){maxCol--;ui();if(running&&showRunTraj)enableRunTraj();needTraj=1;requestDraw();}});

$('increasePocketSizeBtn').addEventListener('click',()=>{if(pocketSize<1.1){pocketSize=Math.min(1.1,+(pocketSize+.05).toFixed(2));makePockets();ui();needBg=needTraj=1;requestDraw();}});
$('decreasePocketSizeBtn').addEventListener('click',()=>{if(pocketSize>0.5){pocketSize=Math.max(0.5,+(pocketSize-.05).toFixed(2));makePockets();ui();needBg=needTraj=1;requestDraw();}});

$('showTrajectoryDuringSimulation').addEventListener('change',e=>{showRunTraj=e.target.checked;if(running)showRunTraj?enableRunTraj():disableRunTraj();needTraj=1;requestDraw();});
$('angleFineTune').addEventListener('input',e=>setFine(+e.target.value));

// ①：白球初始位置模式循环切换（标准→随机→自由→标准）
$('cuePosModeBtn').addEventListener('click',()=>{
  cueMode=(cueMode+1)%3;
  ui(); init();
});

// layout buttons
const setLayout=k=>{currentLayout=k;spotX=2+(Math.random()-.5)*0.25;spotY=H/2+(Math.random()-.5)*0.25;needBg=1;init();};
$('layout1Btn').addEventListener('click',()=>setLayout('1'));
$('layout2Btn').addEventListener('click',()=>setLayout('2'));
$('layout3Btn').addEventListener('click',()=>setLayout('3'));
$('layout4Btn').addEventListener('click',()=>setLayout('4'));
$('layout6Btn').addEventListener('click',()=>setLayout('6'));
$('layout9Btn').addEventListener('click',()=>setLayout('9'));
$('layout10Btn').addEventListener('click',()=>setLayout('10'));
$('layout15Btn').addEventListener('click',()=>setLayout('15'));

// collapsible
window.toggleSection=function(sectionId){
  const content=$(sectionId+'-content'),icon=$(sectionId+'-icon');
  content.classList.toggle('show'); icon.classList.toggle('rotated');
  setTimeout(()=>{const sp=$('sidePanel');sp.style.overflow='hidden';setTimeout(()=>sp.style.overflow='',100);},0);
};
document.addEventListener('DOMContentLoaded',()=>['physics','prediction','table'].forEach(s=>{$(s+'-content')?.classList.remove('show');$(s+'-icon')?.classList.remove('rotated');}));

// resize
new ResizeObserver(resize).observe(canvas);
window.addEventListener('orientationchange',resize);
window.addEventListener('resize',resize);

ui(); init(); resize();
})();
</script>
</body>
</html>
